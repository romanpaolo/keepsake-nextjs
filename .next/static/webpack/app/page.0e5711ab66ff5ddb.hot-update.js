"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useCamera.ts":
/*!****************************!*\
  !*** ./hooks/useCamera.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCamera: () => (/* binding */ useCamera)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst useCamera = (settings)=>{\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [stream, setStream] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [hasPermission, setHasPermission] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [facingMode, setFacingMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(settings.facingMode);\n    const stopStream = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCamera.useCallback[stopStream]\": ()=>{\n            if (stream) {\n                stream.getTracks().forEach({\n                    \"useCamera.useCallback[stopStream]\": (track)=>track.stop()\n                }[\"useCamera.useCallback[stopStream]\"]);\n                setStream(null);\n            }\n        }\n    }[\"useCamera.useCallback[stopStream]\"], [\n        stream\n    ]);\n    const startStream = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCamera.useCallback[startStream]\": async ()=>{\n            setIsLoading(true);\n            setError(null);\n            try {\n                const constraints = {\n                    video: {\n                        width: {\n                            ideal: settings.width\n                        },\n                        height: {\n                            ideal: settings.height\n                        },\n                        facingMode: facingMode\n                    },\n                    audio: false\n                };\n                const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);\n                if (videoRef.current) {\n                    videoRef.current.srcObject = mediaStream;\n                    // Wait for the video to be ready before playing\n                    try {\n                        await videoRef.current.play();\n                    } catch (playError) {\n                        // Ignore play errors - the video will auto-play when ready\n                        console.log(\"Video play interrupted, will auto-play when ready\");\n                    }\n                }\n                setStream(mediaStream);\n                setHasPermission(true);\n            } catch (err) {\n                const errorMessage = err instanceof Error ? err.message : \"Failed to access camera\";\n                setError(errorMessage);\n                setHasPermission(false);\n                if (errorMessage.includes(\"Permission denied\")) {\n                    setError(\"Camera permission denied. Please allow camera access to use the photobooth.\");\n                } else if (errorMessage.includes(\"not found\")) {\n                    setError(\"No camera found. Please connect a camera and try again.\");\n                }\n            } finally{\n                setIsLoading(false);\n            }\n        }\n    }[\"useCamera.useCallback[startStream]\"], [\n        settings.width,\n        settings.height,\n        facingMode\n    ]);\n    const requestPermission = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCamera.useCallback[requestPermission]\": async ()=>{\n            await startStream();\n        }\n    }[\"useCamera.useCallback[requestPermission]\"], [\n        startStream\n    ]);\n    const switchCamera = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useCamera.useCallback[switchCamera]\": async ()=>{\n            stopStream();\n            setFacingMode({\n                \"useCamera.useCallback[switchCamera]\": (prev)=>prev === \"user\" ? \"environment\" : \"user\"\n            }[\"useCamera.useCallback[switchCamera]\"]);\n        }\n    }[\"useCamera.useCallback[switchCamera]\"], [\n        stopStream\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCamera.useEffect\": ()=>{\n            if (hasPermission) {\n                startStream();\n            }\n            return ({\n                \"useCamera.useEffect\": ()=>{\n                    stopStream();\n                }\n            })[\"useCamera.useEffect\"];\n        }\n    }[\"useCamera.useEffect\"], [\n        facingMode,\n        hasPermission\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useCamera.useEffect\": ()=>{\n            // Check if camera permissions are already granted\n            navigator.permissions.query({\n                name: 'camera'\n            }).then({\n                \"useCamera.useEffect\": (result)=>{\n                    if (result.state === 'granted') {\n                        setHasPermission(true);\n                        startStream();\n                    }\n                }\n            }[\"useCamera.useEffect\"]).catch({\n                \"useCamera.useEffect\": ()=>{\n                    // Permissions API might not be available\n                    console.log(\"Permissions API not available\");\n                }\n            }[\"useCamera.useEffect\"]);\n        }\n    }[\"useCamera.useEffect\"], []);\n    return {\n        videoRef,\n        stream,\n        isLoading,\n        error,\n        hasPermission,\n        requestPermission,\n        switchCamera\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUcrQixLQUFLO3VDQUFDO29CQUNQLHlDQUF5QztvQkFDekNoQixRQUFRQyxHQUFHLENBQUM7Z0JBQ2Q7O1FBQ0Y7OEJBQUcsRUFBRTtJQUVMLE9BQU87UUFDTGhDO1FBQ0FDO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0ErQjtRQUNBQztJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3JvbWFuL0RldmVsb3BtZW50L2tlZXBzYWtlL3JldHJvL3JldHJvLWFwcGxlLXBob3RvYm9vdGgvaG9va3MvdXNlQ2FtZXJhLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IENhbWVyYVNldHRpbmdzIH0gZnJvbSBcIkAvbGliL3R5cGVzXCI7XG5cbmludGVyZmFjZSBVc2VDYW1lcmFSZXR1cm4ge1xuICB2aWRlb1JlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsPjtcbiAgc3RyZWFtOiBNZWRpYVN0cmVhbSB8IG51bGw7XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG4gIGhhc1Blcm1pc3Npb246IGJvb2xlYW47XG4gIHJlcXVlc3RQZXJtaXNzaW9uOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBzd2l0Y2hDYW1lcmE6ICgpID0+IFByb21pc2U8dm9pZD47XG59XG5cbmV4cG9ydCBjb25zdCB1c2VDYW1lcmEgPSAoc2V0dGluZ3M6IENhbWVyYVNldHRpbmdzKTogVXNlQ2FtZXJhUmV0dXJuID0+IHtcbiAgY29uc3QgdmlkZW9SZWYgPSB1c2VSZWY8SFRNTFZpZGVvRWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IFtzdHJlYW0sIHNldFN0cmVhbV0gPSB1c2VTdGF0ZTxNZWRpYVN0cmVhbSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaGFzUGVybWlzc2lvbiwgc2V0SGFzUGVybWlzc2lvbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtmYWNpbmdNb2RlLCBzZXRGYWNpbmdNb2RlXSA9IHVzZVN0YXRlPFwidXNlclwiIHwgXCJlbnZpcm9ubWVudFwiPihzZXR0aW5ncy5mYWNpbmdNb2RlKTtcblxuICBjb25zdCBzdG9wU3RyZWFtID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICBzZXRTdHJlYW0obnVsbCk7XG4gICAgfVxuICB9LCBbc3RyZWFtXSk7XG5cbiAgY29uc3Qgc3RhcnRTdHJlYW0gPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzID0ge1xuICAgICAgICB2aWRlbzoge1xuICAgICAgICAgIHdpZHRoOiB7IGlkZWFsOiBzZXR0aW5ncy53aWR0aCB9LFxuICAgICAgICAgIGhlaWdodDogeyBpZGVhbDogc2V0dGluZ3MuaGVpZ2h0IH0sXG4gICAgICAgICAgZmFjaW5nTW9kZTogZmFjaW5nTW9kZSxcbiAgICAgICAgfSxcbiAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbWVkaWFTdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG5cbiAgICAgIGlmICh2aWRlb1JlZi5jdXJyZW50KSB7XG4gICAgICAgIHZpZGVvUmVmLmN1cnJlbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG5cbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHZpZGVvIHRvIGJlIHJlYWR5IGJlZm9yZSBwbGF5aW5nXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdmlkZW9SZWYuY3VycmVudC5wbGF5KCk7XG4gICAgICAgIH0gY2F0Y2ggKHBsYXlFcnJvcikge1xuICAgICAgICAgIC8vIElnbm9yZSBwbGF5IGVycm9ycyAtIHRoZSB2aWRlbyB3aWxsIGF1dG8tcGxheSB3aGVuIHJlYWR5XG4gICAgICAgICAgY29uc29sZS5sb2coXCJWaWRlbyBwbGF5IGludGVycnVwdGVkLCB3aWxsIGF1dG8tcGxheSB3aGVuIHJlYWR5XCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldFN0cmVhbShtZWRpYVN0cmVhbSk7XG4gICAgICBzZXRIYXNQZXJtaXNzaW9uKHRydWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiRmFpbGVkIHRvIGFjY2VzcyBjYW1lcmFcIjtcbiAgICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICBzZXRIYXNQZXJtaXNzaW9uKGZhbHNlKTtcbiAgICAgIFxuICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcIlBlcm1pc3Npb24gZGVuaWVkXCIpKSB7XG4gICAgICAgIHNldEVycm9yKFwiQ2FtZXJhIHBlcm1pc3Npb24gZGVuaWVkLiBQbGVhc2UgYWxsb3cgY2FtZXJhIGFjY2VzcyB0byB1c2UgdGhlIHBob3RvYm9vdGguXCIpO1xuICAgICAgfSBlbHNlIGlmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoXCJub3QgZm91bmRcIikpIHtcbiAgICAgICAgc2V0RXJyb3IoXCJObyBjYW1lcmEgZm91bmQuIFBsZWFzZSBjb25uZWN0IGEgY2FtZXJhIGFuZCB0cnkgYWdhaW4uXCIpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW3NldHRpbmdzLndpZHRoLCBzZXR0aW5ncy5oZWlnaHQsIGZhY2luZ01vZGVdKTtcblxuICBjb25zdCByZXF1ZXN0UGVybWlzc2lvbiA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBzdGFydFN0cmVhbSgpO1xuICB9LCBbc3RhcnRTdHJlYW1dKTtcblxuICBjb25zdCBzd2l0Y2hDYW1lcmEgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgc3RvcFN0cmVhbSgpO1xuICAgIHNldEZhY2luZ01vZGUocHJldiA9PiBwcmV2ID09PSBcInVzZXJcIiA/IFwiZW52aXJvbm1lbnRcIiA6IFwidXNlclwiKTtcbiAgfSwgW3N0b3BTdHJlYW1dKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChoYXNQZXJtaXNzaW9uKSB7XG4gICAgICBzdGFydFN0cmVhbSgpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdG9wU3RyZWFtKCk7XG4gICAgfTtcbiAgfSwgW2ZhY2luZ01vZGUsIGhhc1Blcm1pc3Npb25dKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIENoZWNrIGlmIGNhbWVyYSBwZXJtaXNzaW9ucyBhcmUgYWxyZWFkeSBncmFudGVkXG4gICAgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHsgbmFtZTogJ2NhbWVyYScgYXMgUGVybWlzc2lvbk5hbWUgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBpZiAocmVzdWx0LnN0YXRlID09PSAnZ3JhbnRlZCcpIHtcbiAgICAgICAgc2V0SGFzUGVybWlzc2lvbih0cnVlKTtcbiAgICAgICAgc3RhcnRTdHJlYW0oKTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAvLyBQZXJtaXNzaW9ucyBBUEkgbWlnaHQgbm90IGJlIGF2YWlsYWJsZVxuICAgICAgY29uc29sZS5sb2coXCJQZXJtaXNzaW9ucyBBUEkgbm90IGF2YWlsYWJsZVwiKTtcbiAgICB9KTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgdmlkZW9SZWYsXG4gICAgc3RyZWFtLFxuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBoYXNQZXJtaXNzaW9uLFxuICAgIHJlcXVlc3RQZXJtaXNzaW9uLFxuICAgIHN3aXRjaENhbWVyYSxcbiAgfTtcbn07Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VDYW1lcmEiLCJzZXR0aW5ncyIsInZpZGVvUmVmIiwic3RyZWFtIiwic2V0U3RyZWFtIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImhhc1Blcm1pc3Npb24iLCJzZXRIYXNQZXJtaXNzaW9uIiwiZmFjaW5nTW9kZSIsInNldEZhY2luZ01vZGUiLCJzdG9wU3RyZWFtIiwiZ2V0VHJhY2tzIiwiZm9yRWFjaCIsInRyYWNrIiwic3RvcCIsInN0YXJ0U3RyZWFtIiwiY29uc3RyYWludHMiLCJ2aWRlbyIsIndpZHRoIiwiaWRlYWwiLCJoZWlnaHQiLCJhdWRpbyIsIm1lZGlhU3RyZWFtIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiY3VycmVudCIsInNyY09iamVjdCIsInBsYXkiLCJwbGF5RXJyb3IiLCJjb25zb2xlIiwibG9nIiwiZXJyIiwiZXJyb3JNZXNzYWdlIiwiRXJyb3IiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJyZXF1ZXN0UGVybWlzc2lvbiIsInN3aXRjaENhbWVyYSIsInByZXYiLCJwZXJtaXNzaW9ucyIsInF1ZXJ5IiwibmFtZSIsInRoZW4iLCJyZXN1bHQiLCJzdGF0ZSIsImNhdGNoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useCamera.ts\n"));

/***/ })

});