"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/filters.ts":
/*!************************!*\
  !*** ./lib/filters.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCRTEffect: () => (/* binding */ addCRTEffect),\n/* harmony export */   addScanlines: () => (/* binding */ addScanlines),\n/* harmony export */   applyFilter: () => (/* binding */ applyFilter)\n/* harmony export */ });\nconst applyFilter = (canvas, filter)=>{\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const data = imageData.data;\n    switch(filter){\n        case \"35mm-film\":\n            apply35mmFilmFilter(data, canvas.width, canvas.height);\n            break;\n        case \"vintage-sepia\":\n            applyVintageSepiaFilter(data, canvas.width, canvas.height);\n            addVignette(ctx, canvas.width, canvas.height, 0.25);\n            addGrain(ctx, canvas.width, canvas.height, 38);\n            break;\n        case \"bw-minimal\":\n            applyBWMinimalFilter(data);\n            break;\n        case \"bw-v3\":\n            applyBWV3Filter(data);\n            break;\n        case \"kodak-film\":\n            applyKodakFilmFilter(data);\n            break;\n        case \"kodak-portra\":\n            applyKodakPortraFilter(data);\n            break;\n        case \"none\":\n        default:\n            return;\n    }\n    ctx.putImageData(imageData, 0, 0);\n};\n// 35mm Film Filter\n// Based on: Exposure -0.47, Contrast +40, Highlights +23, Shadows -15\n// Clarity -19, Vibrance +13, warm tone\nconst apply35mmFilmFilter = (data, width, height)=>{\n    for(let i = 0; i < data.length; i += 4){\n        let r = data[i];\n        let g = data[i + 1];\n        let b = data[i + 2];\n        // Reduce exposure slightly\n        r *= 0.85;\n        g *= 0.85;\n        b *= 0.85;\n        // Warm tone (add warmth, reduce blue/cyan)\n        r *= 1.12;\n        g *= 1.03;\n        b *= 0.92;\n        // Increase contrast\n        r = ((r / 255 - 0.5) * 1.4 + 0.5) * 255;\n        g = ((g / 255 - 0.5) * 1.4 + 0.5) * 255;\n        b = ((b / 255 - 0.5) * 1.4 + 0.5) * 255;\n        // Boost vibrance (enhance mid-tones)\n        const avg = (r + g + b) / 3;\n        const saturationBoost = 1.13;\n        r = avg + (r - avg) * saturationBoost;\n        g = avg + (g - avg) * saturationBoost;\n        b = avg + (b - avg) * saturationBoost;\n        // Apply tone curve (lift shadows, compress highlights)\n        r = appleToneCurve(r, [\n            [\n                0,\n                0\n            ],\n            [\n                59,\n                62\n            ],\n            [\n                130,\n                127\n            ],\n            [\n                195,\n                197\n            ],\n            [\n                227,\n                228\n            ],\n            [\n                255,\n                255\n            ]\n        ]);\n        g = applyToneCurve(g, [\n            [\n                0,\n                0\n            ],\n            [\n                59,\n                62\n            ],\n            [\n                130,\n                127\n            ],\n            [\n                195,\n                197\n            ],\n            [\n                227,\n                228\n            ],\n            [\n                255,\n                255\n            ]\n        ]);\n        b = applyToneCurve(b, [\n            [\n                0,\n                0\n            ],\n            [\n                59,\n                62\n            ],\n            [\n                130,\n                127\n            ],\n            [\n                195,\n                197\n            ],\n            [\n                227,\n                228\n            ],\n            [\n                255,\n                255\n            ]\n        ]);\n        data[i] = Math.max(0, Math.min(255, r));\n        data[i + 1] = Math.max(0, Math.min(255, g));\n        data[i + 2] = Math.max(0, Math.min(255, b));\n    }\n};\n// Vintage Photobooth Sepia Filter\n// Based on: Exposure +0.08, Contrast -14, Saturation -97 (almost B&W)\n// Split toning: Shadow hue 36째, Highlight hue 45째 (warm sepia tones)\n// Grain 38, Vignette -25\nconst applyVintageSepiaFilter = (data, width, height)=>{\n    for(let i = 0; i < data.length; i += 4){\n        let r = data[i];\n        let g = data[i + 1];\n        let b = data[i + 2];\n        // Convert to grayscale first\n        const gray = 0.299 * r + 0.587 * g + 0.114 * b;\n        // Reduce contrast\n        const adjusted = ((gray / 255 - 0.5) * 0.86 + 0.5) * 255;\n        // Apply sepia tone (warm shadows, warmer highlights)\n        const luminance = adjusted / 255;\n        // Shadow toning (darker areas get cooler sepia)\n        // Highlight toning (brighter areas get warmer sepia)\n        if (luminance < 0.5) {\n            // Shadows: Hue 36째 (orange-brown)\n            r = adjusted * 1.15;\n            g = adjusted * 0.95;\n            b = adjusted * 0.75;\n        } else {\n            // Highlights: Hue 45째 (yellow-orange)\n            r = adjusted * 1.20;\n            g = adjusted * 1.05;\n            b = adjusted * 0.80;\n        }\n        // Slightly lift exposure\n        r *= 1.08;\n        g *= 1.08;\n        b *= 1.08;\n        // Apply vintage tone curve (faded blacks, muted highlights)\n        const curve = [\n            [\n                0,\n                0\n            ],\n            [\n                64,\n                30\n            ],\n            [\n                176,\n                164\n            ],\n            [\n                250,\n                191\n            ]\n        ];\n        r = applyToneCurve(r, curve);\n        g = applyToneCurve(g, curve);\n        b = applyToneCurve(b, curve);\n        data[i] = Math.max(0, Math.min(255, r));\n        data[i + 1] = Math.max(0, Math.min(255, g));\n        data[i + 2] = Math.max(0, Math.min(255, b));\n    }\n};\n// B&W Minimal Filter\n// Based on: High contrast B&W, Exposure -0.15, Contrast +47\n// Highlights -64, Clarity +16\nconst applyBWMinimalFilter = (data)=>{\n    for(let i = 0; i < data.length; i += 4){\n        const r = data[i];\n        const g = data[i + 1];\n        const b = data[i + 2];\n        // Convert to grayscale with custom weighting\n        let gray = 0.299 * r + 0.587 * g + 0.114 * b;\n        // Reduce exposure\n        gray *= 0.85;\n        // Increase contrast significantly\n        gray = ((gray / 255 - 0.5) * 1.47 + 0.5) * 255;\n        // Crush highlights (compress bright areas)\n        if (gray > 180) {\n            gray = 180 + (gray - 180) * 0.5;\n        }\n        // Add clarity (micro-contrast)\n        const clarity = 1.16;\n        gray = ((gray / 255 - 0.5) * clarity + 0.5) * 255;\n        const final = Math.max(0, Math.min(255, gray));\n        data[i] = final;\n        data[i + 1] = final;\n        data[i + 2] = final;\n    }\n};\n// B&W V3 Filter\n// Based on: Extreme contrast B&W, Exposure -0.27, Contrast +69\n// Highlights -81, Shadows +53, Clarity +34\nconst applyBWV3Filter = (data)=>{\n    for(let i = 0; i < data.length; i += 4){\n        const r = data[i];\n        const g = data[i + 1];\n        const b = data[i + 2];\n        // Convert to grayscale\n        let gray = 0.299 * r + 0.587 * g + 0.114 * b;\n        // Reduce exposure\n        gray *= 0.73;\n        // Extreme contrast\n        gray = ((gray / 255 - 0.5) * 1.69 + 0.5) * 255;\n        // Lift shadows significantly\n        if (gray < 100) {\n            gray = gray + (100 - gray) * 0.53;\n        }\n        // Crush highlights dramatically\n        if (gray > 170) {\n            gray = 170 + (gray - 170) * 0.3;\n        }\n        // Add strong clarity\n        const clarity = 1.34;\n        gray = ((gray / 255 - 0.5) * clarity + 0.5) * 255;\n        const final = Math.max(0, Math.min(255, gray));\n        data[i] = final;\n        data[i + 1] = final;\n        data[i + 2] = final;\n    }\n};\n// Kodak Film Filter\n// Based on: Warm nostalgic film look, Exposure +0.25, Contrast +15\n// Vibrance +22, Saturation +10, warm color grading\nconst applyKodakFilmFilter = (data)=>{\n    for(let i = 0; i < data.length; i += 4){\n        let r = data[i];\n        let g = data[i + 1];\n        let b = data[i + 2];\n        // Increase exposure\n        r *= 1.25;\n        g *= 1.25;\n        b *= 1.25;\n        // Add warm Kodak color cast\n        r *= 1.15;\n        g *= 1.05;\n        b *= 0.93;\n        // Increase contrast moderately\n        r = ((r / 255 - 0.5) * 1.15 + 0.5) * 255;\n        g = ((g / 255 - 0.5) * 1.15 + 0.5) * 255;\n        b = ((b / 255 - 0.5) * 1.15 + 0.5) * 255;\n        // Boost vibrance and saturation\n        const avg = (r + g + b) / 3;\n        const vibranceBoost = 1.22;\n        r = avg + (r - avg) * vibranceBoost * 1.10;\n        g = avg + (g - avg) * vibranceBoost * 1.10;\n        b = avg + (b - avg) * vibranceBoost * 1.10;\n        // Kodak signature warm midtone shift\n        const luminance = (r + g + b) / 3 / 255;\n        if (luminance > 0.3 && luminance < 0.7) {\n            r *= 1.08;\n            g *= 1.03;\n        }\n        data[i] = Math.max(0, Math.min(255, r));\n        data[i + 1] = Math.max(0, Math.min(255, g));\n        data[i + 2] = Math.max(0, Math.min(255, b));\n    }\n};\n// Kodak Portra 400 Filter\n// Based on: Soft, creamy skin tones, Exposure +0.12, Contrast -5\n// Highlights -22, Shadows +18, Vibrance +25, soft pastel look\nconst applyKodakPortraFilter = (data)=>{\n    for(let i = 0; i < data.length; i += 4){\n        let r = data[i];\n        let g = data[i + 1];\n        let b = data[i + 2];\n        // Slight exposure boost\n        r *= 1.12;\n        g *= 1.12;\n        b *= 1.12;\n        // Reduce contrast for soft look\n        r = ((r / 255 - 0.5) * 0.95 + 0.5) * 255;\n        g = ((g / 255 - 0.5) * 0.95 + 0.5) * 255;\n        b = ((b / 255 - 0.5) * 0.95 + 0.5) * 255;\n        // Portra's signature creamy warmth\n        r *= 1.08;\n        g *= 1.04;\n        b *= 0.97;\n        // Lift shadows (open up dark areas)\n        const luminance = (r + g + b) / 3;\n        if (luminance < 100) {\n            const lift = 1.18;\n            r *= lift;\n            g *= lift;\n            b *= lift;\n        }\n        // Pull down highlights (soft, not blown out)\n        if (luminance > 180) {\n            const compress = 0.85;\n            r *= compress;\n            g *= compress;\n            b *= compress;\n        }\n        // Boost vibrance for pastel quality\n        const avg = (r + g + b) / 3;\n        const vibranceBoost = 1.25;\n        r = avg + (r - avg) * vibranceBoost;\n        g = avg + (g - avg) * vibranceBoost;\n        b = avg + (b - avg) * vibranceBoost;\n        // Portra green-magenta shift\n        g *= 1.02;\n        data[i] = Math.max(0, Math.min(255, r));\n        data[i + 1] = Math.max(0, Math.min(255, g));\n        data[i + 2] = Math.max(0, Math.min(255, b));\n    }\n};\n// Helper: Apply tone curve\nconst applyToneCurve = (value, curve)=>{\n    const normalized = value / 255;\n    // Find the two points to interpolate between\n    for(let i = 0; i < curve.length - 1; i++){\n        const [x1, y1] = curve[i];\n        const [x2, y2] = curve[i + 1];\n        const nx1 = x1 / 255;\n        const nx2 = x2 / 255;\n        if (normalized >= nx1 && normalized <= nx2) {\n            // Linear interpolation\n            const t = (normalized - nx1) / (nx2 - nx1);\n            const ny1 = y1 / 255;\n            const ny2 = y2 / 255;\n            const result = ny1 + t * (ny2 - ny1);\n            return result * 255;\n        }\n    }\n    return value;\n};\n// Add vignette effect\nconst addVignette = (ctx, width, height, amount)=>{\n    const imageData = ctx.getImageData(0, 0, width, height);\n    const data = imageData.data;\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);\n    for(let y = 0; y < height; y++){\n        for(let x = 0; x < width; x++){\n            const idx = (y * width + x) * 4;\n            const dx = x - centerX;\n            const dy = y - centerY;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            const vignette = 1 - dist / maxDist * amount;\n            data[idx] *= vignette;\n            data[idx + 1] *= vignette;\n            data[idx + 2] *= vignette;\n        }\n    }\n    ctx.putImageData(imageData, 0, 0);\n};\n// Add film grain\nconst addGrain = (ctx, width, height, amount)=>{\n    const imageData = ctx.getImageData(0, 0, width, height);\n    const data = imageData.data;\n    const grainStrength = amount / 100;\n    for(let i = 0; i < data.length; i += 4){\n        const grain = (Math.random() - 0.5) * grainStrength * 50;\n        data[i] = Math.max(0, Math.min(255, data[i] + grain));\n        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + grain));\n        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + grain));\n    }\n    ctx.putImageData(imageData, 0, 0);\n};\n// CRT and Scanlines effects (kept for compatibility)\nconst addCRTEffect = (canvas)=>{\n// CRT not used in Keepsake presets but keeping for potential future use\n};\nconst addScanlines = (canvas)=>{\n// Scanlines not used in Keepsake presets but keeping for potential future use\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM5QyxNQUFNOEQsZUFBZSxDQUFDbEU7QUFDM0Isd0VBQXdFO0FBQzFFLEVBQUU7QUFFSyxNQUFNbUUsZUFBZSxDQUFDbkU7QUFDM0IsOEVBQThFO0FBQ2hGLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yb21hbi9EZXZlbG9wbWVudC9rZWVwc2FrZS9yZXRyby9yZXRyby1hcHBsZS1waG90b2Jvb3RoL2xpYi9maWx0ZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBob3RvRmlsdGVyIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuZXhwb3J0IGNvbnN0IGFwcGx5RmlsdGVyID0gKFxuICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICBmaWx0ZXI6IFBob3RvRmlsdGVyXG4pOiB2b2lkID0+IHtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgaWYgKCFjdHgpIHJldHVybjtcblxuICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblxuICBzd2l0Y2ggKGZpbHRlcikge1xuICAgIGNhc2UgXCIzNW1tLWZpbG1cIjpcbiAgICAgIGFwcGx5MzVtbUZpbG1GaWx0ZXIoZGF0YSwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ2aW50YWdlLXNlcGlhXCI6XG4gICAgICBhcHBseVZpbnRhZ2VTZXBpYUZpbHRlcihkYXRhLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgYWRkVmlnbmV0dGUoY3R4LCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQsIDAuMjUpO1xuICAgICAgYWRkR3JhaW4oY3R4LCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQsIDM4KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJidy1taW5pbWFsXCI6XG4gICAgICBhcHBseUJXTWluaW1hbEZpbHRlcihkYXRhKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJidy12M1wiOlxuICAgICAgYXBwbHlCV1YzRmlsdGVyKGRhdGEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImtvZGFrLWZpbG1cIjpcbiAgICAgIGFwcGx5S29kYWtGaWxtRmlsdGVyKGRhdGEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImtvZGFrLXBvcnRyYVwiOlxuICAgICAgYXBwbHlLb2Rha1BvcnRyYUZpbHRlcihkYXRhKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub25lXCI6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbn07XG5cbi8vIDM1bW0gRmlsbSBGaWx0ZXJcbi8vIEJhc2VkIG9uOiBFeHBvc3VyZSAtMC40NywgQ29udHJhc3QgKzQwLCBIaWdobGlnaHRzICsyMywgU2hhZG93cyAtMTVcbi8vIENsYXJpdHkgLTE5LCBWaWJyYW5jZSArMTMsIHdhcm0gdG9uZVxuY29uc3QgYXBwbHkzNW1tRmlsbUZpbHRlciA9IChkYXRhOiBVaW50OENsYW1wZWRBcnJheSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgbGV0IHIgPSBkYXRhW2ldO1xuICAgIGxldCBnID0gZGF0YVtpICsgMV07XG4gICAgbGV0IGIgPSBkYXRhW2kgKyAyXTtcblxuICAgIC8vIFJlZHVjZSBleHBvc3VyZSBzbGlnaHRseVxuICAgIHIgKj0gMC44NTtcbiAgICBnICo9IDAuODU7XG4gICAgYiAqPSAwLjg1O1xuXG4gICAgLy8gV2FybSB0b25lIChhZGQgd2FybXRoLCByZWR1Y2UgYmx1ZS9jeWFuKVxuICAgIHIgKj0gMS4xMjtcbiAgICBnICo9IDEuMDM7XG4gICAgYiAqPSAwLjkyO1xuXG4gICAgLy8gSW5jcmVhc2UgY29udHJhc3RcbiAgICByID0gKChyIC8gMjU1IC0gMC41KSAqIDEuNCArIDAuNSkgKiAyNTU7XG4gICAgZyA9ICgoZyAvIDI1NSAtIDAuNSkgKiAxLjQgKyAwLjUpICogMjU1O1xuICAgIGIgPSAoKGIgLyAyNTUgLSAwLjUpICogMS40ICsgMC41KSAqIDI1NTtcblxuICAgIC8vIEJvb3N0IHZpYnJhbmNlIChlbmhhbmNlIG1pZC10b25lcylcbiAgICBjb25zdCBhdmcgPSAociArIGcgKyBiKSAvIDM7XG4gICAgY29uc3Qgc2F0dXJhdGlvbkJvb3N0ID0gMS4xMztcbiAgICByID0gYXZnICsgKHIgLSBhdmcpICogc2F0dXJhdGlvbkJvb3N0O1xuICAgIGcgPSBhdmcgKyAoZyAtIGF2ZykgKiBzYXR1cmF0aW9uQm9vc3Q7XG4gICAgYiA9IGF2ZyArIChiIC0gYXZnKSAqIHNhdHVyYXRpb25Cb29zdDtcblxuICAgIC8vIEFwcGx5IHRvbmUgY3VydmUgKGxpZnQgc2hhZG93cywgY29tcHJlc3MgaGlnaGxpZ2h0cylcbiAgICByID0gYXBwbGVUb25lQ3VydmUociwgW1xuICAgICAgWzAsIDBdLCBbNTksIDYyXSwgWzEzMCwgMTI3XSwgWzE5NSwgMTk3XSwgWzIyNywgMjI4XSwgWzI1NSwgMjU1XVxuICAgIF0pO1xuICAgIGcgPSBhcHBseVRvbmVDdXJ2ZShnLCBbXG4gICAgICBbMCwgMF0sIFs1OSwgNjJdLCBbMTMwLCAxMjddLCBbMTk1LCAxOTddLCBbMjI3LCAyMjhdLCBbMjU1LCAyNTVdXG4gICAgXSk7XG4gICAgYiA9IGFwcGx5VG9uZUN1cnZlKGIsIFtcbiAgICAgIFswLCAwXSwgWzU5LCA2Ml0sIFsxMzAsIDEyN10sIFsxOTUsIDE5N10sIFsyMjcsIDIyOF0sIFsyNTUsIDI1NV1cbiAgICBdKTtcblxuICAgIGRhdGFbaV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHIpKTtcbiAgICBkYXRhW2kgKyAxXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgZykpO1xuICAgIGRhdGFbaSArIDJdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBiKSk7XG4gIH1cbn07XG5cbi8vIFZpbnRhZ2UgUGhvdG9ib290aCBTZXBpYSBGaWx0ZXJcbi8vIEJhc2VkIG9uOiBFeHBvc3VyZSArMC4wOCwgQ29udHJhc3QgLTE0LCBTYXR1cmF0aW9uIC05NyAoYWxtb3N0IEImVylcbi8vIFNwbGl0IHRvbmluZzogU2hhZG93IGh1ZSAzNsKwLCBIaWdobGlnaHQgaHVlIDQ1wrAgKHdhcm0gc2VwaWEgdG9uZXMpXG4vLyBHcmFpbiAzOCwgVmlnbmV0dGUgLTI1XG5jb25zdCBhcHBseVZpbnRhZ2VTZXBpYUZpbHRlciA9IChkYXRhOiBVaW50OENsYW1wZWRBcnJheSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgbGV0IHIgPSBkYXRhW2ldO1xuICAgIGxldCBnID0gZGF0YVtpICsgMV07XG4gICAgbGV0IGIgPSBkYXRhW2kgKyAyXTtcblxuICAgIC8vIENvbnZlcnQgdG8gZ3JheXNjYWxlIGZpcnN0XG4gICAgY29uc3QgZ3JheSA9IDAuMjk5ICogciArIDAuNTg3ICogZyArIDAuMTE0ICogYjtcblxuICAgIC8vIFJlZHVjZSBjb250cmFzdFxuICAgIGNvbnN0IGFkanVzdGVkID0gKChncmF5IC8gMjU1IC0gMC41KSAqIDAuODYgKyAwLjUpICogMjU1O1xuXG4gICAgLy8gQXBwbHkgc2VwaWEgdG9uZSAod2FybSBzaGFkb3dzLCB3YXJtZXIgaGlnaGxpZ2h0cylcbiAgICBjb25zdCBsdW1pbmFuY2UgPSBhZGp1c3RlZCAvIDI1NTtcblxuICAgIC8vIFNoYWRvdyB0b25pbmcgKGRhcmtlciBhcmVhcyBnZXQgY29vbGVyIHNlcGlhKVxuICAgIC8vIEhpZ2hsaWdodCB0b25pbmcgKGJyaWdodGVyIGFyZWFzIGdldCB3YXJtZXIgc2VwaWEpXG4gICAgaWYgKGx1bWluYW5jZSA8IDAuNSkge1xuICAgICAgLy8gU2hhZG93czogSHVlIDM2wrAgKG9yYW5nZS1icm93bilcbiAgICAgIHIgPSBhZGp1c3RlZCAqIDEuMTU7XG4gICAgICBnID0gYWRqdXN0ZWQgKiAwLjk1O1xuICAgICAgYiA9IGFkanVzdGVkICogMC43NTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSGlnaGxpZ2h0czogSHVlIDQ1wrAgKHllbGxvdy1vcmFuZ2UpXG4gICAgICByID0gYWRqdXN0ZWQgKiAxLjIwO1xuICAgICAgZyA9IGFkanVzdGVkICogMS4wNTtcbiAgICAgIGIgPSBhZGp1c3RlZCAqIDAuODA7XG4gICAgfVxuXG4gICAgLy8gU2xpZ2h0bHkgbGlmdCBleHBvc3VyZVxuICAgIHIgKj0gMS4wODtcbiAgICBnICo9IDEuMDg7XG4gICAgYiAqPSAxLjA4O1xuXG4gICAgLy8gQXBwbHkgdmludGFnZSB0b25lIGN1cnZlIChmYWRlZCBibGFja3MsIG11dGVkIGhpZ2hsaWdodHMpXG4gICAgY29uc3QgY3VydmUgPSBbWzAsIDBdLCBbNjQsIDMwXSwgWzE3NiwgMTY0XSwgWzI1MCwgMTkxXV07XG4gICAgciA9IGFwcGx5VG9uZUN1cnZlKHIsIGN1cnZlKTtcbiAgICBnID0gYXBwbHlUb25lQ3VydmUoZywgY3VydmUpO1xuICAgIGIgPSBhcHBseVRvbmVDdXJ2ZShiLCBjdXJ2ZSk7XG5cbiAgICBkYXRhW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByKSk7XG4gICAgZGF0YVtpICsgMV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIGcpKTtcbiAgICBkYXRhW2kgKyAyXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgYikpO1xuICB9XG59O1xuXG4vLyBCJlcgTWluaW1hbCBGaWx0ZXJcbi8vIEJhc2VkIG9uOiBIaWdoIGNvbnRyYXN0IEImVywgRXhwb3N1cmUgLTAuMTUsIENvbnRyYXN0ICs0N1xuLy8gSGlnaGxpZ2h0cyAtNjQsIENsYXJpdHkgKzE2XG5jb25zdCBhcHBseUJXTWluaW1hbEZpbHRlciA9IChkYXRhOiBVaW50OENsYW1wZWRBcnJheSkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCByID0gZGF0YVtpXTtcbiAgICBjb25zdCBnID0gZGF0YVtpICsgMV07XG4gICAgY29uc3QgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgLy8gQ29udmVydCB0byBncmF5c2NhbGUgd2l0aCBjdXN0b20gd2VpZ2h0aW5nXG4gICAgbGV0IGdyYXkgPSAwLjI5OSAqIHIgKyAwLjU4NyAqIGcgKyAwLjExNCAqIGI7XG5cbiAgICAvLyBSZWR1Y2UgZXhwb3N1cmVcbiAgICBncmF5ICo9IDAuODU7XG5cbiAgICAvLyBJbmNyZWFzZSBjb250cmFzdCBzaWduaWZpY2FudGx5XG4gICAgZ3JheSA9ICgoZ3JheSAvIDI1NSAtIDAuNSkgKiAxLjQ3ICsgMC41KSAqIDI1NTtcblxuICAgIC8vIENydXNoIGhpZ2hsaWdodHMgKGNvbXByZXNzIGJyaWdodCBhcmVhcylcbiAgICBpZiAoZ3JheSA+IDE4MCkge1xuICAgICAgZ3JheSA9IDE4MCArIChncmF5IC0gMTgwKSAqIDAuNTtcbiAgICB9XG5cbiAgICAvLyBBZGQgY2xhcml0eSAobWljcm8tY29udHJhc3QpXG4gICAgY29uc3QgY2xhcml0eSA9IDEuMTY7XG4gICAgZ3JheSA9ICgoZ3JheSAvIDI1NSAtIDAuNSkgKiBjbGFyaXR5ICsgMC41KSAqIDI1NTtcblxuICAgIGNvbnN0IGZpbmFsID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBncmF5KSk7XG4gICAgZGF0YVtpXSA9IGZpbmFsO1xuICAgIGRhdGFbaSArIDFdID0gZmluYWw7XG4gICAgZGF0YVtpICsgMl0gPSBmaW5hbDtcbiAgfVxufTtcblxuLy8gQiZXIFYzIEZpbHRlclxuLy8gQmFzZWQgb246IEV4dHJlbWUgY29udHJhc3QgQiZXLCBFeHBvc3VyZSAtMC4yNywgQ29udHJhc3QgKzY5XG4vLyBIaWdobGlnaHRzIC04MSwgU2hhZG93cyArNTMsIENsYXJpdHkgKzM0XG5jb25zdCBhcHBseUJXVjNGaWx0ZXIgPSAoZGF0YTogVWludDhDbGFtcGVkQXJyYXkpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgY29uc3QgciA9IGRhdGFbaV07XG4gICAgY29uc3QgZyA9IGRhdGFbaSArIDFdO1xuICAgIGNvbnN0IGIgPSBkYXRhW2kgKyAyXTtcblxuICAgIC8vIENvbnZlcnQgdG8gZ3JheXNjYWxlXG4gICAgbGV0IGdyYXkgPSAwLjI5OSAqIHIgKyAwLjU4NyAqIGcgKyAwLjExNCAqIGI7XG5cbiAgICAvLyBSZWR1Y2UgZXhwb3N1cmVcbiAgICBncmF5ICo9IDAuNzM7XG5cbiAgICAvLyBFeHRyZW1lIGNvbnRyYXN0XG4gICAgZ3JheSA9ICgoZ3JheSAvIDI1NSAtIDAuNSkgKiAxLjY5ICsgMC41KSAqIDI1NTtcblxuICAgIC8vIExpZnQgc2hhZG93cyBzaWduaWZpY2FudGx5XG4gICAgaWYgKGdyYXkgPCAxMDApIHtcbiAgICAgIGdyYXkgPSBncmF5ICsgKDEwMCAtIGdyYXkpICogMC41MztcbiAgICB9XG5cbiAgICAvLyBDcnVzaCBoaWdobGlnaHRzIGRyYW1hdGljYWxseVxuICAgIGlmIChncmF5ID4gMTcwKSB7XG4gICAgICBncmF5ID0gMTcwICsgKGdyYXkgLSAxNzApICogMC4zO1xuICAgIH1cblxuICAgIC8vIEFkZCBzdHJvbmcgY2xhcml0eVxuICAgIGNvbnN0IGNsYXJpdHkgPSAxLjM0O1xuICAgIGdyYXkgPSAoKGdyYXkgLyAyNTUgLSAwLjUpICogY2xhcml0eSArIDAuNSkgKiAyNTU7XG5cbiAgICBjb25zdCBmaW5hbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgZ3JheSkpO1xuICAgIGRhdGFbaV0gPSBmaW5hbDtcbiAgICBkYXRhW2kgKyAxXSA9IGZpbmFsO1xuICAgIGRhdGFbaSArIDJdID0gZmluYWw7XG4gIH1cbn07XG5cbi8vIEtvZGFrIEZpbG0gRmlsdGVyXG4vLyBCYXNlZCBvbjogV2FybSBub3N0YWxnaWMgZmlsbSBsb29rLCBFeHBvc3VyZSArMC4yNSwgQ29udHJhc3QgKzE1XG4vLyBWaWJyYW5jZSArMjIsIFNhdHVyYXRpb24gKzEwLCB3YXJtIGNvbG9yIGdyYWRpbmdcbmNvbnN0IGFwcGx5S29kYWtGaWxtRmlsdGVyID0gKGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5KSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGxldCByID0gZGF0YVtpXTtcbiAgICBsZXQgZyA9IGRhdGFbaSArIDFdO1xuICAgIGxldCBiID0gZGF0YVtpICsgMl07XG5cbiAgICAvLyBJbmNyZWFzZSBleHBvc3VyZVxuICAgIHIgKj0gMS4yNTtcbiAgICBnICo9IDEuMjU7XG4gICAgYiAqPSAxLjI1O1xuXG4gICAgLy8gQWRkIHdhcm0gS29kYWsgY29sb3IgY2FzdFxuICAgIHIgKj0gMS4xNTtcbiAgICBnICo9IDEuMDU7XG4gICAgYiAqPSAwLjkzO1xuXG4gICAgLy8gSW5jcmVhc2UgY29udHJhc3QgbW9kZXJhdGVseVxuICAgIHIgPSAoKHIgLyAyNTUgLSAwLjUpICogMS4xNSArIDAuNSkgKiAyNTU7XG4gICAgZyA9ICgoZyAvIDI1NSAtIDAuNSkgKiAxLjE1ICsgMC41KSAqIDI1NTtcbiAgICBiID0gKChiIC8gMjU1IC0gMC41KSAqIDEuMTUgKyAwLjUpICogMjU1O1xuXG4gICAgLy8gQm9vc3QgdmlicmFuY2UgYW5kIHNhdHVyYXRpb25cbiAgICBjb25zdCBhdmcgPSAociArIGcgKyBiKSAvIDM7XG4gICAgY29uc3QgdmlicmFuY2VCb29zdCA9IDEuMjI7XG4gICAgciA9IGF2ZyArIChyIC0gYXZnKSAqIHZpYnJhbmNlQm9vc3QgKiAxLjEwO1xuICAgIGcgPSBhdmcgKyAoZyAtIGF2ZykgKiB2aWJyYW5jZUJvb3N0ICogMS4xMDtcbiAgICBiID0gYXZnICsgKGIgLSBhdmcpICogdmlicmFuY2VCb29zdCAqIDEuMTA7XG5cbiAgICAvLyBLb2RhayBzaWduYXR1cmUgd2FybSBtaWR0b25lIHNoaWZ0XG4gICAgY29uc3QgbHVtaW5hbmNlID0gKHIgKyBnICsgYikgLyAzIC8gMjU1O1xuICAgIGlmIChsdW1pbmFuY2UgPiAwLjMgJiYgbHVtaW5hbmNlIDwgMC43KSB7XG4gICAgICByICo9IDEuMDg7XG4gICAgICBnICo9IDEuMDM7XG4gICAgfVxuXG4gICAgZGF0YVtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcikpO1xuICAgIGRhdGFbaSArIDFdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBnKSk7XG4gICAgZGF0YVtpICsgMl0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIGIpKTtcbiAgfVxufTtcblxuLy8gS29kYWsgUG9ydHJhIDQwMCBGaWx0ZXJcbi8vIEJhc2VkIG9uOiBTb2Z0LCBjcmVhbXkgc2tpbiB0b25lcywgRXhwb3N1cmUgKzAuMTIsIENvbnRyYXN0IC01XG4vLyBIaWdobGlnaHRzIC0yMiwgU2hhZG93cyArMTgsIFZpYnJhbmNlICsyNSwgc29mdCBwYXN0ZWwgbG9va1xuY29uc3QgYXBwbHlLb2Rha1BvcnRyYUZpbHRlciA9IChkYXRhOiBVaW50OENsYW1wZWRBcnJheSkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBsZXQgciA9IGRhdGFbaV07XG4gICAgbGV0IGcgPSBkYXRhW2kgKyAxXTtcbiAgICBsZXQgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgLy8gU2xpZ2h0IGV4cG9zdXJlIGJvb3N0XG4gICAgciAqPSAxLjEyO1xuICAgIGcgKj0gMS4xMjtcbiAgICBiICo9IDEuMTI7XG5cbiAgICAvLyBSZWR1Y2UgY29udHJhc3QgZm9yIHNvZnQgbG9va1xuICAgIHIgPSAoKHIgLyAyNTUgLSAwLjUpICogMC45NSArIDAuNSkgKiAyNTU7XG4gICAgZyA9ICgoZyAvIDI1NSAtIDAuNSkgKiAwLjk1ICsgMC41KSAqIDI1NTtcbiAgICBiID0gKChiIC8gMjU1IC0gMC41KSAqIDAuOTUgKyAwLjUpICogMjU1O1xuXG4gICAgLy8gUG9ydHJhJ3Mgc2lnbmF0dXJlIGNyZWFteSB3YXJtdGhcbiAgICByICo9IDEuMDg7XG4gICAgZyAqPSAxLjA0O1xuICAgIGIgKj0gMC45NztcblxuICAgIC8vIExpZnQgc2hhZG93cyAob3BlbiB1cCBkYXJrIGFyZWFzKVxuICAgIGNvbnN0IGx1bWluYW5jZSA9IChyICsgZyArIGIpIC8gMztcbiAgICBpZiAobHVtaW5hbmNlIDwgMTAwKSB7XG4gICAgICBjb25zdCBsaWZ0ID0gMS4xODtcbiAgICAgIHIgKj0gbGlmdDtcbiAgICAgIGcgKj0gbGlmdDtcbiAgICAgIGIgKj0gbGlmdDtcbiAgICB9XG5cbiAgICAvLyBQdWxsIGRvd24gaGlnaGxpZ2h0cyAoc29mdCwgbm90IGJsb3duIG91dClcbiAgICBpZiAobHVtaW5hbmNlID4gMTgwKSB7XG4gICAgICBjb25zdCBjb21wcmVzcyA9IDAuODU7XG4gICAgICByICo9IGNvbXByZXNzO1xuICAgICAgZyAqPSBjb21wcmVzcztcbiAgICAgIGIgKj0gY29tcHJlc3M7XG4gICAgfVxuXG4gICAgLy8gQm9vc3QgdmlicmFuY2UgZm9yIHBhc3RlbCBxdWFsaXR5XG4gICAgY29uc3QgYXZnID0gKHIgKyBnICsgYikgLyAzO1xuICAgIGNvbnN0IHZpYnJhbmNlQm9vc3QgPSAxLjI1O1xuICAgIHIgPSBhdmcgKyAociAtIGF2ZykgKiB2aWJyYW5jZUJvb3N0O1xuICAgIGcgPSBhdmcgKyAoZyAtIGF2ZykgKiB2aWJyYW5jZUJvb3N0O1xuICAgIGIgPSBhdmcgKyAoYiAtIGF2ZykgKiB2aWJyYW5jZUJvb3N0O1xuXG4gICAgLy8gUG9ydHJhIGdyZWVuLW1hZ2VudGEgc2hpZnRcbiAgICBnICo9IDEuMDI7XG5cbiAgICBkYXRhW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByKSk7XG4gICAgZGF0YVtpICsgMV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIGcpKTtcbiAgICBkYXRhW2kgKyAyXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgYikpO1xuICB9XG59O1xuXG4vLyBIZWxwZXI6IEFwcGx5IHRvbmUgY3VydmVcbmNvbnN0IGFwcGx5VG9uZUN1cnZlID0gKHZhbHVlOiBudW1iZXIsIGN1cnZlOiBudW1iZXJbXVtdKTogbnVtYmVyID0+IHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHZhbHVlIC8gMjU1O1xuXG4gIC8vIEZpbmQgdGhlIHR3byBwb2ludHMgdG8gaW50ZXJwb2xhdGUgYmV0d2VlblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnZlLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGNvbnN0IFt4MSwgeTFdID0gY3VydmVbaV07XG4gICAgY29uc3QgW3gyLCB5Ml0gPSBjdXJ2ZVtpICsgMV07XG5cbiAgICBjb25zdCBueDEgPSB4MSAvIDI1NTtcbiAgICBjb25zdCBueDIgPSB4MiAvIDI1NTtcblxuICAgIGlmIChub3JtYWxpemVkID49IG54MSAmJiBub3JtYWxpemVkIDw9IG54Mikge1xuICAgICAgLy8gTGluZWFyIGludGVycG9sYXRpb25cbiAgICAgIGNvbnN0IHQgPSAobm9ybWFsaXplZCAtIG54MSkgLyAobngyIC0gbngxKTtcbiAgICAgIGNvbnN0IG55MSA9IHkxIC8gMjU1O1xuICAgICAgY29uc3QgbnkyID0geTIgLyAyNTU7XG4gICAgICBjb25zdCByZXN1bHQgPSBueTEgKyB0ICogKG55MiAtIG55MSk7XG4gICAgICByZXR1cm4gcmVzdWx0ICogMjU1O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIEFkZCB2aWduZXR0ZSBlZmZlY3RcbmNvbnN0IGFkZFZpZ25ldHRlID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgYW1vdW50OiBudW1iZXIpID0+IHtcbiAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICBjb25zdCBjZW50ZXJYID0gd2lkdGggLyAyO1xuICBjb25zdCBjZW50ZXJZID0gaGVpZ2h0IC8gMjtcbiAgY29uc3QgbWF4RGlzdCA9IE1hdGguc3FydChjZW50ZXJYICogY2VudGVyWCArIGNlbnRlclkgKiBjZW50ZXJZKTtcblxuICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICBjb25zdCBpZHggPSAoeSAqIHdpZHRoICsgeCkgKiA0O1xuICAgICAgY29uc3QgZHggPSB4IC0gY2VudGVyWDtcbiAgICAgIGNvbnN0IGR5ID0geSAtIGNlbnRlclk7XG4gICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIGNvbnN0IHZpZ25ldHRlID0gMSAtIChkaXN0IC8gbWF4RGlzdCkgKiBhbW91bnQ7XG5cbiAgICAgIGRhdGFbaWR4XSAqPSB2aWduZXR0ZTtcbiAgICAgIGRhdGFbaWR4ICsgMV0gKj0gdmlnbmV0dGU7XG4gICAgICBkYXRhW2lkeCArIDJdICo9IHZpZ25ldHRlO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbn07XG5cbi8vIEFkZCBmaWxtIGdyYWluXG5jb25zdCBhZGRHcmFpbiA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGFtb3VudDogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgY29uc3QgZ3JhaW5TdHJlbmd0aCA9IGFtb3VudCAvIDEwMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCBncmFpbiA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIGdyYWluU3RyZW5ndGggKiA1MDtcbiAgICBkYXRhW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBkYXRhW2ldICsgZ3JhaW4pKTtcbiAgICBkYXRhW2kgKyAxXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgZGF0YVtpICsgMV0gKyBncmFpbikpO1xuICAgIGRhdGFbaSArIDJdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBkYXRhW2kgKyAyXSArIGdyYWluKSk7XG4gIH1cblxuICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG59O1xuXG4vLyBDUlQgYW5kIFNjYW5saW5lcyBlZmZlY3RzIChrZXB0IGZvciBjb21wYXRpYmlsaXR5KVxuZXhwb3J0IGNvbnN0IGFkZENSVEVmZmVjdCA9IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XG4gIC8vIENSVCBub3QgdXNlZCBpbiBLZWVwc2FrZSBwcmVzZXRzIGJ1dCBrZWVwaW5nIGZvciBwb3RlbnRpYWwgZnV0dXJlIHVzZVxufTtcblxuZXhwb3J0IGNvbnN0IGFkZFNjYW5saW5lcyA9IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XG4gIC8vIFNjYW5saW5lcyBub3QgdXNlZCBpbiBLZWVwc2FrZSBwcmVzZXRzIGJ1dCBrZWVwaW5nIGZvciBwb3RlbnRpYWwgZnV0dXJlIHVzZVxufTtcbiJdLCJuYW1lcyI6WyJhcHBseUZpbHRlciIsImNhbnZhcyIsImZpbHRlciIsImN0eCIsImdldENvbnRleHQiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJ3aWR0aCIsImhlaWdodCIsImRhdGEiLCJhcHBseTM1bW1GaWxtRmlsdGVyIiwiYXBwbHlWaW50YWdlU2VwaWFGaWx0ZXIiLCJhZGRWaWduZXR0ZSIsImFkZEdyYWluIiwiYXBwbHlCV01pbmltYWxGaWx0ZXIiLCJhcHBseUJXVjNGaWx0ZXIiLCJhcHBseUtvZGFrRmlsbUZpbHRlciIsImFwcGx5S29kYWtQb3J0cmFGaWx0ZXIiLCJwdXRJbWFnZURhdGEiLCJpIiwibGVuZ3RoIiwiciIsImciLCJiIiwiYXZnIiwic2F0dXJhdGlvbkJvb3N0IiwiYXBwbGVUb25lQ3VydmUiLCJhcHBseVRvbmVDdXJ2ZSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJncmF5IiwiYWRqdXN0ZWQiLCJsdW1pbmFuY2UiLCJjdXJ2ZSIsImNsYXJpdHkiLCJmaW5hbCIsInZpYnJhbmNlQm9vc3QiLCJsaWZ0IiwiY29tcHJlc3MiLCJ2YWx1ZSIsIm5vcm1hbGl6ZWQiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIm54MSIsIm54MiIsInQiLCJueTEiLCJueTIiLCJyZXN1bHQiLCJhbW91bnQiLCJjZW50ZXJYIiwiY2VudGVyWSIsIm1heERpc3QiLCJzcXJ0IiwieSIsIngiLCJpZHgiLCJkeCIsImR5IiwiZGlzdCIsInZpZ25ldHRlIiwiZ3JhaW5TdHJlbmd0aCIsImdyYWluIiwicmFuZG9tIiwiYWRkQ1JURWZmZWN0IiwiYWRkU2NhbmxpbmVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/filters.ts\n"));

/***/ })

});