"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/utils.ts":
/*!**********************!*\
  !*** ./lib/utils.ts ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPhotoStrip: () => (/* binding */ createPhotoStrip),\n/* harmony export */   downloadImage: () => (/* binding */ downloadImage),\n/* harmony export */   generatePhotoId: () => (/* binding */ generatePhotoId),\n/* harmony export */   playSound: () => (/* binding */ playSound)\n/* harmony export */ });\nconst generatePhotoId = ()=>{\n    return \"photo-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n};\nconst downloadImage = (dataUrl, filename)=>{\n    const link = document.createElement(\"a\");\n    link.href = dataUrl;\n    link.download = filename;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n};\nconst createPhotoStrip = async (photos, theme)=>{\n    const canvas = document.createElement(\"canvas\");\n    const ctx = canvas.getContext(\"2d\");\n    // Print-ready dimensions: 2x6 inches at 300 DPI\n    // 2 inches wide × 300 DPI = 600px\n    // 6 inches tall × 300 DPI = 1800px\n    const printWidth = 600; // 2 inches at 300 DPI\n    const printHeight = 1800; // 6 inches at 300 DPI\n    const blackBorder = 60; // Black border around edge (0.2 inches)\n    const padding = 10; // Space between photos\n    const bleedAmount = 3; // Edge bleeding/overflow amount\n    // Calculate photo dimensions maintaining 4:3 aspect ratio\n    const photoWidth = printWidth - blackBorder * 2; // Full available width\n    const totalPadding = (photos.length - 1) * padding;\n    const availableHeight = printHeight - blackBorder * 2 - totalPadding;\n    const photoHeight = availableHeight / photos.length; // Equal height for each photo\n    // Maintain 4:3 aspect ratio (most camera photos)\n    const aspectRatio = 4 / 3;\n    let finalPhotoWidth = photoWidth;\n    let finalPhotoHeight = photoWidth / aspectRatio;\n    // If photo height exceeds available space, scale down\n    if (finalPhotoHeight > photoHeight) {\n        finalPhotoHeight = photoHeight;\n        finalPhotoWidth = photoHeight * aspectRatio;\n    }\n    // Center photos horizontally within the width\n    const photoStartX = blackBorder + (photoWidth - finalPhotoWidth) / 2;\n    canvas.width = printWidth;\n    canvas.height = printHeight;\n    // Black background (film strip look) - completely black\n    ctx.fillStyle = \"#000000\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    // Draw photos with edge bleeding effect\n    for(let i = 0; i < photos.length; i++){\n        const img = new Image();\n        img.src = photos[i].dataUrl;\n        await new Promise((resolve)=>{\n            img.onload = ()=>{\n                const x = blackBorder + padding;\n                const y = blackBorder + padding + i * (photoHeight + padding);\n                // Draw photo with slight overflow into padding for bleed effect\n                ctx.drawImage(img, x - bleedAmount, y - bleedAmount, photoWidth + bleedAmount * 2, photoHeight + bleedAmount * 2);\n                // Add edge blur/fade effect (vignette-like bleeding)\n                const blurGradient = ctx.createLinearGradient(x, y, x + photoWidth, y);\n                blurGradient.addColorStop(0, \"rgba(0, 0, 0, 0.15)\");\n                blurGradient.addColorStop(0.1, \"rgba(0, 0, 0, 0)\");\n                blurGradient.addColorStop(0.9, \"rgba(0, 0, 0, 0)\");\n                blurGradient.addColorStop(1, \"rgba(0, 0, 0, 0.15)\");\n                ctx.fillStyle = blurGradient;\n                ctx.fillRect(x, y, photoWidth, photoHeight);\n                // Add vertical edge blur\n                const verticalGradient = ctx.createLinearGradient(x, y, x, y + photoHeight);\n                verticalGradient.addColorStop(0, \"rgba(0, 0, 0, 0.1)\");\n                verticalGradient.addColorStop(0.08, \"rgba(0, 0, 0, 0)\");\n                verticalGradient.addColorStop(0.92, \"rgba(0, 0, 0, 0)\");\n                verticalGradient.addColorStop(1, \"rgba(0, 0, 0, 0.1)\");\n                ctx.fillStyle = verticalGradient;\n                ctx.fillRect(x, y, photoWidth, photoHeight);\n                resolve(null);\n            };\n        });\n    }\n    // Add date stamp at bottom\n    const date = new Date().toLocaleDateString();\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.font = \"16px monospace\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(date, canvas.width / 2, canvas.height - 20);\n    return canvas.toDataURL(\"image/png\");\n};\nconst playSound = (soundName)=>{\n    // Create audio context for sound effects\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    switch(soundName){\n        case \"shutter\":\n            // Simulate camera shutter sound\n            const oscillator = audioContext.createOscillator();\n            const gainNode = audioContext.createGain();\n            oscillator.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n            oscillator.frequency.value = 1000;\n            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);\n            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);\n            oscillator.start(audioContext.currentTime);\n            oscillator.stop(audioContext.currentTime + 0.1);\n            break;\n        case \"countdown\":\n            // Simple beep for countdown\n            const beep = audioContext.createOscillator();\n            const beepGain = audioContext.createGain();\n            beep.connect(beepGain);\n            beepGain.connect(audioContext.destination);\n            beep.frequency.value = 800;\n            beepGain.gain.setValueAtTime(0.2, audioContext.currentTime);\n            beepGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);\n            beep.start(audioContext.currentTime);\n            beep.stop(audioContext.currentTime + 0.05);\n            break;\n        case \"flash\":\n            // White noise burst for flash\n            const bufferSize = audioContext.sampleRate * 0.05;\n            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);\n            const output = buffer.getChannelData(0);\n            for(let i = 0; i < bufferSize; i++){\n                output[i] = Math.random() * 2 - 1;\n            }\n            const whiteNoise = audioContext.createBufferSource();\n            const noiseGain = audioContext.createGain();\n            whiteNoise.buffer = buffer;\n            whiteNoise.connect(noiseGain);\n            noiseGain.connect(audioContext.destination);\n            noiseGain.gain.setValueAtTime(0.1, audioContext.currentTime);\n            noiseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);\n            whiteNoise.start(audioContext.currentTime);\n            break;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFBWTVCLGFBQWFPLFVBQVU7WUFFekNtQixXQUFXSixNQUFNLEdBQUdBO1lBQ3BCSSxXQUFXbEIsT0FBTyxDQUFDb0I7WUFDbkJBLFVBQVVwQixPQUFPLENBQUNSLGFBQWFTLFdBQVc7WUFFMUNtQixVQUFVaEIsSUFBSSxDQUFDQyxjQUFjLENBQUMsS0FBS2IsYUFBYWMsV0FBVztZQUMzRGMsVUFBVWhCLElBQUksQ0FBQ0csNEJBQTRCLENBQUMsTUFBTWYsYUFBYWMsV0FBVyxHQUFHO1lBRTdFWSxXQUFXVixLQUFLLENBQUNoQixhQUFhYyxXQUFXO1lBQ3pDO0lBQ0o7QUFDRixFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvcm9tYW4vRGV2ZWxvcG1lbnQva2VlcHNha2UtbmV4dGpzL2xpYi91dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaG90bywgUGhvdG9TdHJpcExheW91dCB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVBob3RvSWQgPSAoKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGBwaG90by0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG59O1xuXG5leHBvcnQgY29uc3QgZG93bmxvYWRJbWFnZSA9IChkYXRhVXJsOiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICBsaW5rLmhyZWYgPSBkYXRhVXJsO1xuICBsaW5rLmRvd25sb2FkID0gZmlsZW5hbWU7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gIGxpbmsuY2xpY2soKTtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQaG90b1N0cmlwID0gYXN5bmMgKFxuICBwaG90b3M6IFBob3RvW10sXG4gIHRoZW1lOiBzdHJpbmdcbik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikhO1xuXG4gIC8vIFByaW50LXJlYWR5IGRpbWVuc2lvbnM6IDJ4NiBpbmNoZXMgYXQgMzAwIERQSVxuICAvLyAyIGluY2hlcyB3aWRlIMOXIDMwMCBEUEkgPSA2MDBweFxuICAvLyA2IGluY2hlcyB0YWxsIMOXIDMwMCBEUEkgPSAxODAwcHhcbiAgY29uc3QgcHJpbnRXaWR0aCA9IDYwMDsgICAvLyAyIGluY2hlcyBhdCAzMDAgRFBJXG4gIGNvbnN0IHByaW50SGVpZ2h0ID0gMTgwMDsgLy8gNiBpbmNoZXMgYXQgMzAwIERQSVxuXG4gIGNvbnN0IGJsYWNrQm9yZGVyID0gNjA7ICAgLy8gQmxhY2sgYm9yZGVyIGFyb3VuZCBlZGdlICgwLjIgaW5jaGVzKVxuICBjb25zdCBwYWRkaW5nID0gMTA7ICAgICAgIC8vIFNwYWNlIGJldHdlZW4gcGhvdG9zXG4gIGNvbnN0IGJsZWVkQW1vdW50ID0gMzsgICAgLy8gRWRnZSBibGVlZGluZy9vdmVyZmxvdyBhbW91bnRcblxuICAvLyBDYWxjdWxhdGUgcGhvdG8gZGltZW5zaW9ucyBtYWludGFpbmluZyA0OjMgYXNwZWN0IHJhdGlvXG4gIGNvbnN0IHBob3RvV2lkdGggPSBwcmludFdpZHRoIC0gKGJsYWNrQm9yZGVyICogMik7ICAvLyBGdWxsIGF2YWlsYWJsZSB3aWR0aFxuICBjb25zdCB0b3RhbFBhZGRpbmcgPSAocGhvdG9zLmxlbmd0aCAtIDEpICogcGFkZGluZztcbiAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gcHJpbnRIZWlnaHQgLSAoYmxhY2tCb3JkZXIgKiAyKSAtIHRvdGFsUGFkZGluZztcbiAgY29uc3QgcGhvdG9IZWlnaHQgPSBhdmFpbGFibGVIZWlnaHQgLyBwaG90b3MubGVuZ3RoOyAvLyBFcXVhbCBoZWlnaHQgZm9yIGVhY2ggcGhvdG9cblxuICAvLyBNYWludGFpbiA0OjMgYXNwZWN0IHJhdGlvIChtb3N0IGNhbWVyYSBwaG90b3MpXG4gIGNvbnN0IGFzcGVjdFJhdGlvID0gNCAvIDM7XG4gIGxldCBmaW5hbFBob3RvV2lkdGggPSBwaG90b1dpZHRoO1xuICBsZXQgZmluYWxQaG90b0hlaWdodCA9IHBob3RvV2lkdGggLyBhc3BlY3RSYXRpbztcblxuICAvLyBJZiBwaG90byBoZWlnaHQgZXhjZWVkcyBhdmFpbGFibGUgc3BhY2UsIHNjYWxlIGRvd25cbiAgaWYgKGZpbmFsUGhvdG9IZWlnaHQgPiBwaG90b0hlaWdodCkge1xuICAgIGZpbmFsUGhvdG9IZWlnaHQgPSBwaG90b0hlaWdodDtcbiAgICBmaW5hbFBob3RvV2lkdGggPSBwaG90b0hlaWdodCAqIGFzcGVjdFJhdGlvO1xuICB9XG5cbiAgLy8gQ2VudGVyIHBob3RvcyBob3Jpem9udGFsbHkgd2l0aGluIHRoZSB3aWR0aFxuICBjb25zdCBwaG90b1N0YXJ0WCA9IGJsYWNrQm9yZGVyICsgKHBob3RvV2lkdGggLSBmaW5hbFBob3RvV2lkdGgpIC8gMjtcblxuICBjYW52YXMud2lkdGggPSBwcmludFdpZHRoO1xuICBjYW52YXMuaGVpZ2h0ID0gcHJpbnRIZWlnaHQ7XG5cbiAgLy8gQmxhY2sgYmFja2dyb3VuZCAoZmlsbSBzdHJpcCBsb29rKSAtIGNvbXBsZXRlbHkgYmxhY2tcbiAgY3R4LmZpbGxTdHlsZSA9IFwiIzAwMDAwMFwiO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAvLyBEcmF3IHBob3RvcyB3aXRoIGVkZ2UgYmxlZWRpbmcgZWZmZWN0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGhvdG9zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLnNyYyA9IHBob3Rvc1tpXS5kYXRhVXJsO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB4ID0gYmxhY2tCb3JkZXIgKyBwYWRkaW5nO1xuICAgICAgICBjb25zdCB5ID0gYmxhY2tCb3JkZXIgKyBwYWRkaW5nICsgKGkgKiAocGhvdG9IZWlnaHQgKyBwYWRkaW5nKSk7XG5cbiAgICAgICAgLy8gRHJhdyBwaG90byB3aXRoIHNsaWdodCBvdmVyZmxvdyBpbnRvIHBhZGRpbmcgZm9yIGJsZWVkIGVmZmVjdFxuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgeCAtIGJsZWVkQW1vdW50LCB5IC0gYmxlZWRBbW91bnQsIHBob3RvV2lkdGggKyAoYmxlZWRBbW91bnQgKiAyKSwgcGhvdG9IZWlnaHQgKyAoYmxlZWRBbW91bnQgKiAyKSk7XG5cbiAgICAgICAgLy8gQWRkIGVkZ2UgYmx1ci9mYWRlIGVmZmVjdCAodmlnbmV0dGUtbGlrZSBibGVlZGluZylcbiAgICAgICAgY29uc3QgYmx1ckdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHggKyBwaG90b1dpZHRoLCB5KTtcbiAgICAgICAgYmx1ckdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBcInJnYmEoMCwgMCwgMCwgMC4xNSlcIik7XG4gICAgICAgIGJsdXJHcmFkaWVudC5hZGRDb2xvclN0b3AoMC4xLCBcInJnYmEoMCwgMCwgMCwgMClcIik7XG4gICAgICAgIGJsdXJHcmFkaWVudC5hZGRDb2xvclN0b3AoMC45LCBcInJnYmEoMCwgMCwgMCwgMClcIik7XG4gICAgICAgIGJsdXJHcmFkaWVudC5hZGRDb2xvclN0b3AoMSwgXCJyZ2JhKDAsIDAsIDAsIDAuMTUpXCIpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmx1ckdyYWRpZW50O1xuICAgICAgICBjdHguZmlsbFJlY3QoeCwgeSwgcGhvdG9XaWR0aCwgcGhvdG9IZWlnaHQpO1xuXG4gICAgICAgIC8vIEFkZCB2ZXJ0aWNhbCBlZGdlIGJsdXJcbiAgICAgICAgY29uc3QgdmVydGljYWxHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4LCB5ICsgcGhvdG9IZWlnaHQpO1xuICAgICAgICB2ZXJ0aWNhbEdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBcInJnYmEoMCwgMCwgMCwgMC4xKVwiKTtcbiAgICAgICAgdmVydGljYWxHcmFkaWVudC5hZGRDb2xvclN0b3AoMC4wOCwgXCJyZ2JhKDAsIDAsIDAsIDApXCIpO1xuICAgICAgICB2ZXJ0aWNhbEdyYWRpZW50LmFkZENvbG9yU3RvcCgwLjkyLCBcInJnYmEoMCwgMCwgMCwgMClcIik7XG4gICAgICAgIHZlcnRpY2FsR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIFwicmdiYSgwLCAwLCAwLCAwLjEpXCIpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdmVydGljYWxHcmFkaWVudDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHksIHBob3RvV2lkdGgsIHBob3RvSGVpZ2h0KTtcblxuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEFkZCBkYXRlIHN0YW1wIGF0IGJvdHRvbVxuICBjb25zdCBkYXRlID0gbmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKTtcbiAgY3R4LmZpbGxTdHlsZSA9IFwiI0ZGRkZGRlwiO1xuICBjdHguZm9udCA9IFwiMTZweCBtb25vc3BhY2VcIjtcbiAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gIGN0eC5maWxsVGV4dChkYXRlLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC0gMjApO1xuXG4gIHJldHVybiBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBsYXlTb3VuZCA9IChzb3VuZE5hbWU6IFwic2h1dHRlclwiIHwgXCJjb3VudGRvd25cIiB8IFwiZmxhc2hcIikgPT4ge1xuICAvLyBDcmVhdGUgYXVkaW8gY29udGV4dCBmb3Igc291bmQgZWZmZWN0c1xuICBjb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgKHdpbmRvdyBhcyBhbnkpLndlYmtpdEF1ZGlvQ29udGV4dCkoKTtcbiAgXG4gIHN3aXRjaCAoc291bmROYW1lKSB7XG4gICAgY2FzZSBcInNodXR0ZXJcIjpcbiAgICAgIC8vIFNpbXVsYXRlIGNhbWVyYSBzaHV0dGVyIHNvdW5kXG4gICAgICBjb25zdCBvc2NpbGxhdG9yID0gYXVkaW9Db250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICAgIGNvbnN0IGdhaW5Ob2RlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICAgIFxuICAgICAgb3NjaWxsYXRvci5jb25uZWN0KGdhaW5Ob2RlKTtcbiAgICAgIGdhaW5Ob2RlLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgIFxuICAgICAgb3NjaWxsYXRvci5mcmVxdWVuY3kudmFsdWUgPSAxMDAwO1xuICAgICAgZ2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLjMsIGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICBnYWluTm9kZS5nYWluLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUoMC4wMSwgYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgMC4xKTtcbiAgICAgIFxuICAgICAgb3NjaWxsYXRvci5zdGFydChhdWRpb0NvbnRleHQuY3VycmVudFRpbWUpO1xuICAgICAgb3NjaWxsYXRvci5zdG9wKGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIDAuMSk7XG4gICAgICBicmVhaztcbiAgICAgIFxuICAgIGNhc2UgXCJjb3VudGRvd25cIjpcbiAgICAgIC8vIFNpbXBsZSBiZWVwIGZvciBjb3VudGRvd25cbiAgICAgIGNvbnN0IGJlZXAgPSBhdWRpb0NvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgY29uc3QgYmVlcEdhaW4gPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgXG4gICAgICBiZWVwLmNvbm5lY3QoYmVlcEdhaW4pO1xuICAgICAgYmVlcEdhaW4uY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgXG4gICAgICBiZWVwLmZyZXF1ZW5jeS52YWx1ZSA9IDgwMDtcbiAgICAgIGJlZXBHYWluLmdhaW4uc2V0VmFsdWVBdFRpbWUoMC4yLCBhdWRpb0NvbnRleHQuY3VycmVudFRpbWUpO1xuICAgICAgYmVlcEdhaW4uZ2Fpbi5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKDAuMDEsIGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIDAuMDUpO1xuICAgICAgXG4gICAgICBiZWVwLnN0YXJ0KGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICBiZWVwLnN0b3AoYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgMC4wNSk7XG4gICAgICBicmVhaztcbiAgICAgIFxuICAgIGNhc2UgXCJmbGFzaFwiOlxuICAgICAgLy8gV2hpdGUgbm9pc2UgYnVyc3QgZm9yIGZsYXNoXG4gICAgICBjb25zdCBidWZmZXJTaXplID0gYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUgKiAwLjA1O1xuICAgICAgY29uc3QgYnVmZmVyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCBidWZmZXJTaXplLCBhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBidWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyU2l6ZTsgaSsrKSB7XG4gICAgICAgIG91dHB1dFtpXSA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgd2hpdGVOb2lzZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgIGNvbnN0IG5vaXNlR2FpbiA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICBcbiAgICAgIHdoaXRlTm9pc2UuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgd2hpdGVOb2lzZS5jb25uZWN0KG5vaXNlR2Fpbik7XG4gICAgICBub2lzZUdhaW4uY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgXG4gICAgICBub2lzZUdhaW4uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLjEsIGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICBub2lzZUdhaW4uZ2Fpbi5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKDAuMDEsIGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIDAuMDUpO1xuICAgICAgXG4gICAgICB3aGl0ZU5vaXNlLnN0YXJ0KGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICBicmVhaztcbiAgfVxufTsiXSwibmFtZXMiOlsiZ2VuZXJhdGVQaG90b0lkIiwiTWF0aCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsImRvd25sb2FkSW1hZ2UiLCJkYXRhVXJsIiwiZmlsZW5hbWUiLCJsaW5rIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaHJlZiIsImRvd25sb2FkIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJyZW1vdmVDaGlsZCIsImNyZWF0ZVBob3RvU3RyaXAiLCJwaG90b3MiLCJ0aGVtZSIsImNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJwcmludFdpZHRoIiwicHJpbnRIZWlnaHQiLCJibGFja0JvcmRlciIsInBhZGRpbmciLCJibGVlZEFtb3VudCIsInBob3RvV2lkdGgiLCJ0b3RhbFBhZGRpbmciLCJsZW5ndGgiLCJhdmFpbGFibGVIZWlnaHQiLCJwaG90b0hlaWdodCIsImFzcGVjdFJhdGlvIiwiZmluYWxQaG90b1dpZHRoIiwiZmluYWxQaG90b0hlaWdodCIsInBob3RvU3RhcnRYIiwid2lkdGgiLCJoZWlnaHQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImkiLCJpbWciLCJJbWFnZSIsInNyYyIsIlByb21pc2UiLCJyZXNvbHZlIiwib25sb2FkIiwieCIsInkiLCJkcmF3SW1hZ2UiLCJibHVyR3JhZGllbnQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsInZlcnRpY2FsR3JhZGllbnQiLCJkYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwiZm9udCIsInRleHRBbGlnbiIsImZpbGxUZXh0IiwidG9EYXRhVVJMIiwicGxheVNvdW5kIiwic291bmROYW1lIiwiYXVkaW9Db250ZXh0Iiwid2luZG93IiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0Iiwib3NjaWxsYXRvciIsImNyZWF0ZU9zY2lsbGF0b3IiLCJnYWluTm9kZSIsImNyZWF0ZUdhaW4iLCJjb25uZWN0IiwiZGVzdGluYXRpb24iLCJmcmVxdWVuY3kiLCJ2YWx1ZSIsImdhaW4iLCJzZXRWYWx1ZUF0VGltZSIsImN1cnJlbnRUaW1lIiwiZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSIsInN0YXJ0Iiwic3RvcCIsImJlZXAiLCJiZWVwR2FpbiIsImJ1ZmZlclNpemUiLCJzYW1wbGVSYXRlIiwiYnVmZmVyIiwiY3JlYXRlQnVmZmVyIiwib3V0cHV0IiwiZ2V0Q2hhbm5lbERhdGEiLCJ3aGl0ZU5vaXNlIiwiY3JlYXRlQnVmZmVyU291cmNlIiwibm9pc2VHYWluIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/utils.ts\n"));

/***/ })

});