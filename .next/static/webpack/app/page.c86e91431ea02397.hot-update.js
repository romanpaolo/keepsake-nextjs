"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/filters.ts":
/*!************************!*\
  !*** ./lib/filters.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCRTEffect: () => (/* binding */ addCRTEffect),\n/* harmony export */   addScanlines: () => (/* binding */ addScanlines),\n/* harmony export */   applyFilter: () => (/* binding */ applyFilter)\n/* harmony export */ });\nconst applyFilter = (canvas, filter)=>{\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const data = imageData.data;\n    switch(filter){\n        case \"35mm-film\":\n            apply35mmFilmFilter(data, canvas.width, canvas.height);\n            break;\n        case \"vintage-sepia\":\n            applyVintageSepiaFilter(data, canvas.width, canvas.height);\n            addVignette(ctx, canvas.width, canvas.height, 0.25);\n            addGrain(ctx, canvas.width, canvas.height, 38);\n            break;\n        case \"bw-minimal\":\n            applyBWMinimalFilter(data);\n            break;\n        case \"bw-v3\":\n            applyBWV3Filter(data);\n            break;\n        case \"kodak-film\":\n            applyKodakFilmFilter(data);\n            break;\n        case \"kodak-portra\":\n            applyKodakPortraFilter(data);\n            break;\n        case \"none\":\n        default:\n            return;\n    }\n    ctx.putImageData(imageData, 0, 0);\n};\n// 35mm Film Filter\n// Based on: Exposure -0.47, Contrast +40, Highlights +23, Shadows -15\n// Clarity -19, Vibrance +13, warm tone\nconst apply35mmFilmFilter = (data, width, height)=>{\n    for(let i = 0; i < data.length; i += 4){\n        let r = data[i];\n        let g = data[i + 1];\n        let b = data[i + 2];\n        // Reduce exposure slightly\n        r *= 0.85;\n        g *= 0.85;\n        b *= 0.85;\n        // Warm tone (add warmth, reduce blue/cyan)\n        r *= 1.12;\n        g *= 1.03;\n        b *= 0.92;\n        // Increase contrast\n        r = ((r / 255 - 0.5) * 1.4 + 0.5) * 255;\n        g = ((g / 255 - 0.5) * 1.4 + 0.5) * 255;\n        b = ((b / 255 - 0.5) * 1.4 + 0.5) * 255;\n        // Boost vibrance (enhance mid-tones)\n        const avg = (r + g + b) / 3;\n        const saturationBoost = 1.13;\n        r = avg + (r - avg) * saturationBoost;\n        g = avg + (g - avg) * saturationBoost;\n        b = avg + (b - avg) * saturationBoost;\n        // Apply tone curve (lift shadows, compress highlights)\n        r = applyToneCurve(r, [\n            [\n                0,\n                0\n            ],\n            [\n                59,\n                62\n            ],\n            [\n                130,\n                127\n            ],\n            [\n                195,\n                197\n            ],\n            [\n                227,\n                228\n            ],\n            [\n                255,\n                255\n            ]\n        ]);\n        g = applyToneCurve(g, [\n            [\n                0,\n                0\n            ],\n            [\n                59,\n                62\n            ],\n            [\n                130,\n                127\n            ],\n            [\n                195,\n                197\n            ],\n            [\n                227,\n                228\n            ],\n            [\n                255,\n                255\n            ]\n        ]);\n        b = applyToneCurve(b, [\n            [\n                0,\n                0\n            ],\n            [\n                59,\n                62\n            ],\n            [\n                130,\n                127\n            ],\n            [\n                195,\n                197\n            ],\n            [\n                227,\n                228\n            ],\n            [\n                255,\n                255\n            ]\n        ]);\n        data[i] = Math.max(0, Math.min(255, r));\n        data[i + 1] = Math.max(0, Math.min(255, g));\n        data[i + 2] = Math.max(0, Math.min(255, b));\n    }\n};\n// Vintage Photobooth Filter\n// High contrast B&W with subtle warm tint, blown-out highlights, deep shadows\n// Authentic 1970s department store photobooth aesthetic\n// NOT traditional sepia - this is 95% grayscale with minimal warmth\nconst applyVintageSepiaFilter = (data, width, height)=>{\n    for(let i = 0; i < data.length; i += 4){\n        let r = data[i];\n        let g = data[i + 1];\n        let b = data[i + 2];\n        // 1. Convert to grayscale with custom weights (emphasize red channel for luminous skin)\n        const gray = r * 0.4 + g * 0.4 + b * 0.2;\n        // 2. Apply S-curve for high contrast with blown highlights and deep shadows\n        let adjusted = gray / 255;\n        // Brighten midtones\n        adjusted = Math.pow(adjusted, 0.7);\n        // Apply contrast curve\n        if (adjusted > 0.5) {\n            // Boost highlights (create blown-out bright areas on skin)\n            adjusted = 0.5 + Math.pow((adjusted - 0.5) * 2, 0.8) * 0.5;\n        } else {\n            // Deepen shadows while retaining detail\n            adjusted = Math.pow(adjusted * 2, 1.3) * 0.5;\n        }\n        adjusted = adjusted * 255;\n        // 3. Add VERY subtle warm tint (barely noticeable - not brown sepia)\n        r = Math.min(255, adjusted * 1.02); // Tiny red boost\n        g = Math.min(255, adjusted * 0.99); // Slight green reduction\n        b = Math.min(255, adjusted * 0.97); // Slight blue reduction\n        data[i] = Math.max(0, Math.min(255, r));\n        data[i + 1] = Math.max(0, Math.min(255, g));\n        data[i + 2] = Math.max(0, Math.min(255, b));\n    }\n};\n// B&W Minimal Filter\n// Based on: High contrast B&W, Exposure -0.15, Contrast +47\n// Highlights -64, Clarity +16\nconst applyBWMinimalFilter = (data)=>{\n    for(let i = 0; i < data.length; i += 4){\n        const r = data[i];\n        const g = data[i + 1];\n        const b = data[i + 2];\n        // Convert to grayscale with custom weighting\n        let gray = 0.299 * r + 0.587 * g + 0.114 * b;\n        // Reduce exposure\n        gray *= 0.85;\n        // Increase contrast significantly\n        gray = ((gray / 255 - 0.5) * 1.47 + 0.5) * 255;\n        // Crush highlights (compress bright areas)\n        if (gray > 180) {\n            gray = 180 + (gray - 180) * 0.5;\n        }\n        // Add clarity (micro-contrast)\n        const clarity = 1.16;\n        gray = ((gray / 255 - 0.5) * clarity + 0.5) * 255;\n        const final = Math.max(0, Math.min(255, gray));\n        data[i] = final;\n        data[i + 1] = final;\n        data[i + 2] = final;\n    }\n};\n// B&W V3 Filter\n// Based on: Extreme contrast B&W, Exposure -0.27, Contrast +69\n// Highlights -81, Shadows +53, Clarity +34\nconst applyBWV3Filter = (data)=>{\n    for(let i = 0; i < data.length; i += 4){\n        const r = data[i];\n        const g = data[i + 1];\n        const b = data[i + 2];\n        // Convert to grayscale\n        let gray = 0.299 * r + 0.587 * g + 0.114 * b;\n        // Reduce exposure\n        gray *= 0.73;\n        // Extreme contrast\n        gray = ((gray / 255 - 0.5) * 1.69 + 0.5) * 255;\n        // Lift shadows significantly\n        if (gray < 100) {\n            gray = gray + (100 - gray) * 0.53;\n        }\n        // Crush highlights dramatically\n        if (gray > 170) {\n            gray = 170 + (gray - 170) * 0.3;\n        }\n        // Add strong clarity\n        const clarity = 1.34;\n        gray = ((gray / 255 - 0.5) * clarity + 0.5) * 255;\n        const final = Math.max(0, Math.min(255, gray));\n        data[i] = final;\n        data[i + 1] = final;\n        data[i + 2] = final;\n    }\n};\n// Kodak Film Filter\n// Based on: Warm nostalgic film look, Exposure +0.25, Contrast +15\n// Vibrance +22, Saturation +10, warm color grading\nconst applyKodakFilmFilter = (data)=>{\n    for(let i = 0; i < data.length; i += 4){\n        let r = data[i];\n        let g = data[i + 1];\n        let b = data[i + 2];\n        // Increase exposure\n        r *= 1.25;\n        g *= 1.25;\n        b *= 1.25;\n        // Add warm Kodak color cast\n        r *= 1.15;\n        g *= 1.05;\n        b *= 0.93;\n        // Increase contrast moderately\n        r = ((r / 255 - 0.5) * 1.15 + 0.5) * 255;\n        g = ((g / 255 - 0.5) * 1.15 + 0.5) * 255;\n        b = ((b / 255 - 0.5) * 1.15 + 0.5) * 255;\n        // Boost vibrance and saturation\n        const avg = (r + g + b) / 3;\n        const vibranceBoost = 1.22;\n        r = avg + (r - avg) * vibranceBoost * 1.10;\n        g = avg + (g - avg) * vibranceBoost * 1.10;\n        b = avg + (b - avg) * vibranceBoost * 1.10;\n        // Kodak signature warm midtone shift\n        const luminance = (r + g + b) / 3 / 255;\n        if (luminance > 0.3 && luminance < 0.7) {\n            r *= 1.08;\n            g *= 1.03;\n        }\n        data[i] = Math.max(0, Math.min(255, r));\n        data[i + 1] = Math.max(0, Math.min(255, g));\n        data[i + 2] = Math.max(0, Math.min(255, b));\n    }\n};\n// Kodak Portra 400 Filter\n// Based on: Soft, creamy skin tones, Exposure +0.12, Contrast -5\n// Highlights -22, Shadows +18, Vibrance +25, soft pastel look\nconst applyKodakPortraFilter = (data)=>{\n    for(let i = 0; i < data.length; i += 4){\n        let r = data[i];\n        let g = data[i + 1];\n        let b = data[i + 2];\n        // Slight exposure boost\n        r *= 1.12;\n        g *= 1.12;\n        b *= 1.12;\n        // Reduce contrast for soft look\n        r = ((r / 255 - 0.5) * 0.95 + 0.5) * 255;\n        g = ((g / 255 - 0.5) * 0.95 + 0.5) * 255;\n        b = ((b / 255 - 0.5) * 0.95 + 0.5) * 255;\n        // Portra's signature creamy warmth\n        r *= 1.08;\n        g *= 1.04;\n        b *= 0.97;\n        // Lift shadows (open up dark areas)\n        const luminance = (r + g + b) / 3;\n        if (luminance < 100) {\n            const lift = 1.18;\n            r *= lift;\n            g *= lift;\n            b *= lift;\n        }\n        // Pull down highlights (soft, not blown out)\n        if (luminance > 180) {\n            const compress = 0.85;\n            r *= compress;\n            g *= compress;\n            b *= compress;\n        }\n        // Boost vibrance for pastel quality\n        const avg = (r + g + b) / 3;\n        const vibranceBoost = 1.25;\n        r = avg + (r - avg) * vibranceBoost;\n        g = avg + (g - avg) * vibranceBoost;\n        b = avg + (b - avg) * vibranceBoost;\n        // Portra green-magenta shift\n        g *= 1.02;\n        data[i] = Math.max(0, Math.min(255, r));\n        data[i + 1] = Math.max(0, Math.min(255, g));\n        data[i + 2] = Math.max(0, Math.min(255, b));\n    }\n};\n// Helper: Apply tone curve\nconst applyToneCurve = (value, curve)=>{\n    const normalized = value / 255;\n    // Find the two points to interpolate between\n    for(let i = 0; i < curve.length - 1; i++){\n        const [x1, y1] = curve[i];\n        const [x2, y2] = curve[i + 1];\n        const nx1 = x1 / 255;\n        const nx2 = x2 / 255;\n        if (normalized >= nx1 && normalized <= nx2) {\n            // Linear interpolation\n            const t = (normalized - nx1) / (nx2 - nx1);\n            const ny1 = y1 / 255;\n            const ny2 = y2 / 255;\n            const result = ny1 + t * (ny2 - ny1);\n            return result * 255;\n        }\n    }\n    return value;\n};\n// Add vignette effect\nconst addVignette = (ctx, width, height, amount)=>{\n    const imageData = ctx.getImageData(0, 0, width, height);\n    const data = imageData.data;\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);\n    for(let y = 0; y < height; y++){\n        for(let x = 0; x < width; x++){\n            const idx = (y * width + x) * 4;\n            const dx = x - centerX;\n            const dy = y - centerY;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            const vignette = 1 - dist / maxDist * amount;\n            data[idx] *= vignette;\n            data[idx + 1] *= vignette;\n            data[idx + 2] *= vignette;\n        }\n    }\n    ctx.putImageData(imageData, 0, 0);\n};\n// Add film grain\nconst addGrain = (ctx, width, height, amount)=>{\n    const imageData = ctx.getImageData(0, 0, width, height);\n    const data = imageData.data;\n    const grainStrength = amount / 100;\n    for(let i = 0; i < data.length; i += 4){\n        const grain = (Math.random() - 0.5) * grainStrength * 50;\n        data[i] = Math.max(0, Math.min(255, data[i] + grain));\n        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + grain));\n        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + grain));\n    }\n    ctx.putImageData(imageData, 0, 0);\n};\n// CRT and Scanlines effects (kept for compatibility)\nconst addCRTEffect = (canvas)=>{\n// CRT not used in Keepsake presets but keeping for potential future use\n};\nconst addScanlines = (canvas)=>{\n// Scanlines not used in Keepsake presets but keeping for potential future use\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9maWx0ZXJzLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUVPLE1BQU1BLGNBQWMsQ0FDekJDLFFBQ0FDO0lBRUEsTUFBTUMsTUFBTUYsT0FBT0csVUFBVSxDQUFDO0lBQzlCLElBQUksQ0FBQ0QsS0FBSztJQUVWLE1BQU1FLFlBQVlGLElBQUlHLFlBQVksQ0FBQyxHQUFHLEdBQUdMLE9BQU9NLEtBQUssRUFBRU4sT0FBT08sTUFBTTtJQUNwRSxNQUFNQyxPQUFPSixVQUFVSSxJQUFJO0lBRTNCLE9BQVFQO1FBQ04sS0FBSztZQUNIUSxvQkFBb0JELE1BQU1SLE9BQU9NLEtBQUssRUFBRU4sT0FBT08sTUFBTTtZQUNyRDtRQUNGLEtBQUs7WUFDSEcsd0JBQXdCRixNQUFNUixPQUFPTSxLQUFLLEVBQUVOLE9BQU9PLE1BQU07WUFDekRJLFlBQVlULEtBQUtGLE9BQU9NLEtBQUssRUFBRU4sT0FBT08sTUFBTSxFQUFFO1lBQzlDSyxTQUFTVixLQUFLRixPQUFPTSxLQUFLLEVBQUVOLE9BQU9PLE1BQU0sRUFBRTtZQUMzQztRQUNGLEtBQUs7WUFDSE0scUJBQXFCTDtZQUNyQjtRQUNGLEtBQUs7WUFDSE0sZ0JBQWdCTjtZQUNoQjtRQUNGLEtBQUs7WUFDSE8scUJBQXFCUDtZQUNyQjtRQUNGLEtBQUs7WUFDSFEsdUJBQXVCUjtZQUN2QjtRQUNGLEtBQUs7UUFDTDtZQUNFO0lBQ0o7SUFFQU4sSUFBSWUsWUFBWSxDQUFDYixXQUFXLEdBQUc7QUFDakMsRUFBRTtBQUVGLG1CQUFtQjtBQUNuQixzRUFBc0U7QUFDdEUsdUNBQXVDO0FBQ3ZDLE1BQU1LLHNCQUFzQixDQUFDRCxNQUF5QkYsT0FBZUM7SUFDbkUsSUFBSyxJQUFJVyxJQUFJLEdBQUdBLElBQUlWLEtBQUtXLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3ZDLElBQUlFLElBQUlaLElBQUksQ0FBQ1UsRUFBRTtRQUNmLElBQUlHLElBQUliLElBQUksQ0FBQ1UsSUFBSSxFQUFFO1FBQ25CLElBQUlJLElBQUlkLElBQUksQ0FBQ1UsSUFBSSxFQUFFO1FBRW5CLDJCQUEyQjtRQUMzQkUsS0FBSztRQUNMQyxLQUFLO1FBQ0xDLEtBQUs7UUFFTCwyQ0FBMkM7UUFDM0NGLEtBQUs7UUFDTEMsS0FBSztRQUNMQyxLQUFLO1FBRUwsb0JBQW9CO1FBQ3BCRixJQUFJLENBQUMsQ0FBQ0EsSUFBSSxNQUFNLEdBQUUsSUFBSyxNQUFNLEdBQUUsSUFBSztRQUNwQ0MsSUFBSSxDQUFDLENBQUNBLElBQUksTUFBTSxHQUFFLElBQUssTUFBTSxHQUFFLElBQUs7UUFDcENDLElBQUksQ0FBQyxDQUFDQSxJQUFJLE1BQU0sR0FBRSxJQUFLLE1BQU0sR0FBRSxJQUFLO1FBRXBDLHFDQUFxQztRQUNyQyxNQUFNQyxNQUFNLENBQUNILElBQUlDLElBQUlDLENBQUFBLElBQUs7UUFDMUIsTUFBTUUsa0JBQWtCO1FBQ3hCSixJQUFJRyxNQUFNLENBQUNILElBQUlHLEdBQUUsSUFBS0M7UUFDdEJILElBQUlFLE1BQU0sQ0FBQ0YsSUFBSUUsR0FBRSxJQUFLQztRQUN0QkYsSUFBSUMsTUFBTSxDQUFDRCxJQUFJQyxHQUFFLElBQUtDO1FBRXRCLHVEQUF1RDtRQUN2REosSUFBSUssZUFBZUwsR0FBRztZQUNwQjtnQkFBQztnQkFBRzthQUFFO1lBQUU7Z0JBQUM7Z0JBQUk7YUFBRztZQUFFO2dCQUFDO2dCQUFLO2FBQUk7WUFBRTtnQkFBQztnQkFBSzthQUFJO1lBQUU7Z0JBQUM7Z0JBQUs7YUFBSTtZQUFFO2dCQUFDO2dCQUFLO2FBQUk7U0FDakU7UUFDREMsSUFBSUksZUFBZUosR0FBRztZQUNwQjtnQkFBQztnQkFBRzthQUFFO1lBQUU7Z0JBQUM7Z0JBQUk7YUFBRztZQUFFO2dCQUFDO2dCQUFLO2FBQUk7WUFBRTtnQkFBQztnQkFBSzthQUFJO1lBQUU7Z0JBQUM7Z0JBQUs7YUFBSTtZQUFFO2dCQUFDO2dCQUFLO2FBQUk7U0FDakU7UUFDREMsSUFBSUcsZUFBZUgsR0FBRztZQUNwQjtnQkFBQztnQkFBRzthQUFFO1lBQUU7Z0JBQUM7Z0JBQUk7YUFBRztZQUFFO2dCQUFDO2dCQUFLO2FBQUk7WUFBRTtnQkFBQztnQkFBSzthQUFJO1lBQUU7Z0JBQUM7Z0JBQUs7YUFBSTtZQUFFO2dCQUFDO2dCQUFLO2FBQUk7U0FDakU7UUFFRGQsSUFBSSxDQUFDVSxFQUFFLEdBQUdRLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsS0FBS1I7UUFDcENaLElBQUksQ0FBQ1UsSUFBSSxFQUFFLEdBQUdRLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsS0FBS1A7UUFDeENiLElBQUksQ0FBQ1UsSUFBSSxFQUFFLEdBQUdRLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsS0FBS047SUFDMUM7QUFDRjtBQUVBLDRCQUE0QjtBQUM1Qiw4RUFBOEU7QUFDOUUsd0RBQXdEO0FBQ3hELG9FQUFvRTtBQUNwRSxNQUFNWiwwQkFBMEIsQ0FBQ0YsTUFBeUJGLE9BQWVDO0lBQ3ZFLElBQUssSUFBSVcsSUFBSSxHQUFHQSxJQUFJVixLQUFLVyxNQUFNLEVBQUVELEtBQUssRUFBRztRQUN2QyxJQUFJRSxJQUFJWixJQUFJLENBQUNVLEVBQUU7UUFDZixJQUFJRyxJQUFJYixJQUFJLENBQUNVLElBQUksRUFBRTtRQUNuQixJQUFJSSxJQUFJZCxJQUFJLENBQUNVLElBQUksRUFBRTtRQUVuQix3RkFBd0Y7UUFDeEYsTUFBTVcsT0FBT1QsSUFBSSxNQUFNQyxJQUFJLE1BQU1DLElBQUk7UUFFckMsNEVBQTRFO1FBQzVFLElBQUlRLFdBQVdELE9BQU87UUFFdEIsb0JBQW9CO1FBQ3BCQyxXQUFXSixLQUFLSyxHQUFHLENBQUNELFVBQVU7UUFFOUIsdUJBQXVCO1FBQ3ZCLElBQUlBLFdBQVcsS0FBSztZQUNsQiwyREFBMkQ7WUFDM0RBLFdBQVcsTUFBTUosS0FBS0ssR0FBRyxDQUFDLENBQUNELFdBQVcsR0FBRSxJQUFLLEdBQUcsT0FBTztRQUN6RCxPQUFPO1lBQ0wsd0NBQXdDO1lBQ3hDQSxXQUFXSixLQUFLSyxHQUFHLENBQUNELFdBQVcsR0FBRyxPQUFPO1FBQzNDO1FBRUFBLFdBQVdBLFdBQVc7UUFFdEIscUVBQXFFO1FBQ3JFVixJQUFJTSxLQUFLRSxHQUFHLENBQUMsS0FBS0UsV0FBVyxPQUFRLGlCQUFpQjtRQUN0RFQsSUFBSUssS0FBS0UsR0FBRyxDQUFDLEtBQUtFLFdBQVcsT0FBUSx5QkFBeUI7UUFDOURSLElBQUlJLEtBQUtFLEdBQUcsQ0FBQyxLQUFLRSxXQUFXLE9BQVEsd0JBQXdCO1FBRTdEdEIsSUFBSSxDQUFDVSxFQUFFLEdBQUdRLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsS0FBS1I7UUFDcENaLElBQUksQ0FBQ1UsSUFBSSxFQUFFLEdBQUdRLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsS0FBS1A7UUFDeENiLElBQUksQ0FBQ1UsSUFBSSxFQUFFLEdBQUdRLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsS0FBS047SUFDMUM7QUFDRjtBQUVBLHFCQUFxQjtBQUNyQiw0REFBNEQ7QUFDNUQsOEJBQThCO0FBQzlCLE1BQU1ULHVCQUF1QixDQUFDTDtJQUM1QixJQUFLLElBQUlVLElBQUksR0FBR0EsSUFBSVYsS0FBS1csTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDdkMsTUFBTUUsSUFBSVosSUFBSSxDQUFDVSxFQUFFO1FBQ2pCLE1BQU1HLElBQUliLElBQUksQ0FBQ1UsSUFBSSxFQUFFO1FBQ3JCLE1BQU1JLElBQUlkLElBQUksQ0FBQ1UsSUFBSSxFQUFFO1FBRXJCLDZDQUE2QztRQUM3QyxJQUFJVyxPQUFPLFFBQVFULElBQUksUUFBUUMsSUFBSSxRQUFRQztRQUUzQyxrQkFBa0I7UUFDbEJPLFFBQVE7UUFFUixrQ0FBa0M7UUFDbENBLE9BQU8sQ0FBQyxDQUFDQSxPQUFPLE1BQU0sR0FBRSxJQUFLLE9BQU8sR0FBRSxJQUFLO1FBRTNDLDJDQUEyQztRQUMzQyxJQUFJQSxPQUFPLEtBQUs7WUFDZEEsT0FBTyxNQUFNLENBQUNBLE9BQU8sR0FBRSxJQUFLO1FBQzlCO1FBRUEsK0JBQStCO1FBQy9CLE1BQU1HLFVBQVU7UUFDaEJILE9BQU8sQ0FBQyxDQUFDQSxPQUFPLE1BQU0sR0FBRSxJQUFLRyxVQUFVLEdBQUUsSUFBSztRQUU5QyxNQUFNQyxRQUFRUCxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDLEtBQUtDO1FBQ3hDckIsSUFBSSxDQUFDVSxFQUFFLEdBQUdlO1FBQ1Z6QixJQUFJLENBQUNVLElBQUksRUFBRSxHQUFHZTtRQUNkekIsSUFBSSxDQUFDVSxJQUFJLEVBQUUsR0FBR2U7SUFDaEI7QUFDRjtBQUVBLGdCQUFnQjtBQUNoQiwrREFBK0Q7QUFDL0QsMkNBQTJDO0FBQzNDLE1BQU1uQixrQkFBa0IsQ0FBQ047SUFDdkIsSUFBSyxJQUFJVSxJQUFJLEdBQUdBLElBQUlWLEtBQUtXLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3ZDLE1BQU1FLElBQUlaLElBQUksQ0FBQ1UsRUFBRTtRQUNqQixNQUFNRyxJQUFJYixJQUFJLENBQUNVLElBQUksRUFBRTtRQUNyQixNQUFNSSxJQUFJZCxJQUFJLENBQUNVLElBQUksRUFBRTtRQUVyQix1QkFBdUI7UUFDdkIsSUFBSVcsT0FBTyxRQUFRVCxJQUFJLFFBQVFDLElBQUksUUFBUUM7UUFFM0Msa0JBQWtCO1FBQ2xCTyxRQUFRO1FBRVIsbUJBQW1CO1FBQ25CQSxPQUFPLENBQUMsQ0FBQ0EsT0FBTyxNQUFNLEdBQUUsSUFBSyxPQUFPLEdBQUUsSUFBSztRQUUzQyw2QkFBNkI7UUFDN0IsSUFBSUEsT0FBTyxLQUFLO1lBQ2RBLE9BQU9BLE9BQU8sQ0FBQyxNQUFNQSxJQUFHLElBQUs7UUFDL0I7UUFFQSxnQ0FBZ0M7UUFDaEMsSUFBSUEsT0FBTyxLQUFLO1lBQ2RBLE9BQU8sTUFBTSxDQUFDQSxPQUFPLEdBQUUsSUFBSztRQUM5QjtRQUVBLHFCQUFxQjtRQUNyQixNQUFNRyxVQUFVO1FBQ2hCSCxPQUFPLENBQUMsQ0FBQ0EsT0FBTyxNQUFNLEdBQUUsSUFBS0csVUFBVSxHQUFFLElBQUs7UUFFOUMsTUFBTUMsUUFBUVAsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEdBQUcsQ0FBQyxLQUFLQztRQUN4Q3JCLElBQUksQ0FBQ1UsRUFBRSxHQUFHZTtRQUNWekIsSUFBSSxDQUFDVSxJQUFJLEVBQUUsR0FBR2U7UUFDZHpCLElBQUksQ0FBQ1UsSUFBSSxFQUFFLEdBQUdlO0lBQ2hCO0FBQ0Y7QUFFQSxvQkFBb0I7QUFDcEIsbUVBQW1FO0FBQ25FLG1EQUFtRDtBQUNuRCxNQUFNbEIsdUJBQXVCLENBQUNQO0lBQzVCLElBQUssSUFBSVUsSUFBSSxHQUFHQSxJQUFJVixLQUFLVyxNQUFNLEVBQUVELEtBQUssRUFBRztRQUN2QyxJQUFJRSxJQUFJWixJQUFJLENBQUNVLEVBQUU7UUFDZixJQUFJRyxJQUFJYixJQUFJLENBQUNVLElBQUksRUFBRTtRQUNuQixJQUFJSSxJQUFJZCxJQUFJLENBQUNVLElBQUksRUFBRTtRQUVuQixvQkFBb0I7UUFDcEJFLEtBQUs7UUFDTEMsS0FBSztRQUNMQyxLQUFLO1FBRUwsNEJBQTRCO1FBQzVCRixLQUFLO1FBQ0xDLEtBQUs7UUFDTEMsS0FBSztRQUVMLCtCQUErQjtRQUMvQkYsSUFBSSxDQUFDLENBQUNBLElBQUksTUFBTSxHQUFFLElBQUssT0FBTyxHQUFFLElBQUs7UUFDckNDLElBQUksQ0FBQyxDQUFDQSxJQUFJLE1BQU0sR0FBRSxJQUFLLE9BQU8sR0FBRSxJQUFLO1FBQ3JDQyxJQUFJLENBQUMsQ0FBQ0EsSUFBSSxNQUFNLEdBQUUsSUFBSyxPQUFPLEdBQUUsSUFBSztRQUVyQyxnQ0FBZ0M7UUFDaEMsTUFBTUMsTUFBTSxDQUFDSCxJQUFJQyxJQUFJQyxDQUFBQSxJQUFLO1FBQzFCLE1BQU1ZLGdCQUFnQjtRQUN0QmQsSUFBSUcsTUFBTSxDQUFDSCxJQUFJRyxHQUFFLElBQUtXLGdCQUFnQjtRQUN0Q2IsSUFBSUUsTUFBTSxDQUFDRixJQUFJRSxHQUFFLElBQUtXLGdCQUFnQjtRQUN0Q1osSUFBSUMsTUFBTSxDQUFDRCxJQUFJQyxHQUFFLElBQUtXLGdCQUFnQjtRQUV0QyxxQ0FBcUM7UUFDckMsTUFBTUMsWUFBWSxDQUFDZixJQUFJQyxJQUFJQyxDQUFBQSxJQUFLLElBQUk7UUFDcEMsSUFBSWEsWUFBWSxPQUFPQSxZQUFZLEtBQUs7WUFDdENmLEtBQUs7WUFDTEMsS0FBSztRQUNQO1FBRUFiLElBQUksQ0FBQ1UsRUFBRSxHQUFHUSxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDLEtBQUtSO1FBQ3BDWixJQUFJLENBQUNVLElBQUksRUFBRSxHQUFHUSxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDLEtBQUtQO1FBQ3hDYixJQUFJLENBQUNVLElBQUksRUFBRSxHQUFHUSxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDLEtBQUtOO0lBQzFDO0FBQ0Y7QUFFQSwwQkFBMEI7QUFDMUIsaUVBQWlFO0FBQ2pFLDhEQUE4RDtBQUM5RCxNQUFNTix5QkFBeUIsQ0FBQ1I7SUFDOUIsSUFBSyxJQUFJVSxJQUFJLEdBQUdBLElBQUlWLEtBQUtXLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3ZDLElBQUlFLElBQUlaLElBQUksQ0FBQ1UsRUFBRTtRQUNmLElBQUlHLElBQUliLElBQUksQ0FBQ1UsSUFBSSxFQUFFO1FBQ25CLElBQUlJLElBQUlkLElBQUksQ0FBQ1UsSUFBSSxFQUFFO1FBRW5CLHdCQUF3QjtRQUN4QkUsS0FBSztRQUNMQyxLQUFLO1FBQ0xDLEtBQUs7UUFFTCxnQ0FBZ0M7UUFDaENGLElBQUksQ0FBQyxDQUFDQSxJQUFJLE1BQU0sR0FBRSxJQUFLLE9BQU8sR0FBRSxJQUFLO1FBQ3JDQyxJQUFJLENBQUMsQ0FBQ0EsSUFBSSxNQUFNLEdBQUUsSUFBSyxPQUFPLEdBQUUsSUFBSztRQUNyQ0MsSUFBSSxDQUFDLENBQUNBLElBQUksTUFBTSxHQUFFLElBQUssT0FBTyxHQUFFLElBQUs7UUFFckMsbUNBQW1DO1FBQ25DRixLQUFLO1FBQ0xDLEtBQUs7UUFDTEMsS0FBSztRQUVMLG9DQUFvQztRQUNwQyxNQUFNYSxZQUFZLENBQUNmLElBQUlDLElBQUlDLENBQUFBLElBQUs7UUFDaEMsSUFBSWEsWUFBWSxLQUFLO1lBQ25CLE1BQU1DLE9BQU87WUFDYmhCLEtBQUtnQjtZQUNMZixLQUFLZTtZQUNMZCxLQUFLYztRQUNQO1FBRUEsNkNBQTZDO1FBQzdDLElBQUlELFlBQVksS0FBSztZQUNuQixNQUFNRSxXQUFXO1lBQ2pCakIsS0FBS2lCO1lBQ0xoQixLQUFLZ0I7WUFDTGYsS0FBS2U7UUFDUDtRQUVBLG9DQUFvQztRQUNwQyxNQUFNZCxNQUFNLENBQUNILElBQUlDLElBQUlDLENBQUFBLElBQUs7UUFDMUIsTUFBTVksZ0JBQWdCO1FBQ3RCZCxJQUFJRyxNQUFNLENBQUNILElBQUlHLEdBQUUsSUFBS1c7UUFDdEJiLElBQUlFLE1BQU0sQ0FBQ0YsSUFBSUUsR0FBRSxJQUFLVztRQUN0QlosSUFBSUMsTUFBTSxDQUFDRCxJQUFJQyxHQUFFLElBQUtXO1FBRXRCLDZCQUE2QjtRQUM3QmIsS0FBSztRQUVMYixJQUFJLENBQUNVLEVBQUUsR0FBR1EsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEdBQUcsQ0FBQyxLQUFLUjtRQUNwQ1osSUFBSSxDQUFDVSxJQUFJLEVBQUUsR0FBR1EsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEdBQUcsQ0FBQyxLQUFLUDtRQUN4Q2IsSUFBSSxDQUFDVSxJQUFJLEVBQUUsR0FBR1EsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEdBQUcsQ0FBQyxLQUFLTjtJQUMxQztBQUNGO0FBRUEsMkJBQTJCO0FBQzNCLE1BQU1HLGlCQUFpQixDQUFDYSxPQUFlQztJQUNyQyxNQUFNQyxhQUFhRixRQUFRO0lBRTNCLDZDQUE2QztJQUM3QyxJQUFLLElBQUlwQixJQUFJLEdBQUdBLElBQUlxQixNQUFNcEIsTUFBTSxHQUFHLEdBQUdELElBQUs7UUFDekMsTUFBTSxDQUFDdUIsSUFBSUMsR0FBRyxHQUFHSCxLQUFLLENBQUNyQixFQUFFO1FBQ3pCLE1BQU0sQ0FBQ3lCLElBQUlDLEdBQUcsR0FBR0wsS0FBSyxDQUFDckIsSUFBSSxFQUFFO1FBRTdCLE1BQU0yQixNQUFNSixLQUFLO1FBQ2pCLE1BQU1LLE1BQU1ILEtBQUs7UUFFakIsSUFBSUgsY0FBY0ssT0FBT0wsY0FBY00sS0FBSztZQUMxQyx1QkFBdUI7WUFDdkIsTUFBTUMsSUFBSSxDQUFDUCxhQUFhSyxHQUFFLElBQU1DLENBQUFBLE1BQU1ELEdBQUU7WUFDeEMsTUFBTUcsTUFBTU4sS0FBSztZQUNqQixNQUFNTyxNQUFNTCxLQUFLO1lBQ2pCLE1BQU1NLFNBQVNGLE1BQU1ELElBQUtFLENBQUFBLE1BQU1ELEdBQUU7WUFDbEMsT0FBT0UsU0FBUztRQUNsQjtJQUNGO0lBRUEsT0FBT1o7QUFDVDtBQUVBLHNCQUFzQjtBQUN0QixNQUFNM0IsY0FBYyxDQUFDVCxLQUErQkksT0FBZUMsUUFBZ0I0QztJQUNqRixNQUFNL0MsWUFBWUYsSUFBSUcsWUFBWSxDQUFDLEdBQUcsR0FBR0MsT0FBT0M7SUFDaEQsTUFBTUMsT0FBT0osVUFBVUksSUFBSTtJQUMzQixNQUFNNEMsVUFBVTlDLFFBQVE7SUFDeEIsTUFBTStDLFVBQVU5QyxTQUFTO0lBQ3pCLE1BQU0rQyxVQUFVNUIsS0FBSzZCLElBQUksQ0FBQ0gsVUFBVUEsVUFBVUMsVUFBVUE7SUFFeEQsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlqRCxRQUFRaUQsSUFBSztRQUMvQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSW5ELE9BQU9tRCxJQUFLO1lBQzlCLE1BQU1DLE1BQU0sQ0FBQ0YsSUFBSWxELFFBQVFtRCxDQUFBQSxJQUFLO1lBQzlCLE1BQU1FLEtBQUtGLElBQUlMO1lBQ2YsTUFBTVEsS0FBS0osSUFBSUg7WUFDZixNQUFNUSxPQUFPbkMsS0FBSzZCLElBQUksQ0FBQ0ksS0FBS0EsS0FBS0MsS0FBS0E7WUFDdEMsTUFBTUUsV0FBVyxJQUFJLE9BQVFSLFVBQVdIO1lBRXhDM0MsSUFBSSxDQUFDa0QsSUFBSSxJQUFJSTtZQUNidEQsSUFBSSxDQUFDa0QsTUFBTSxFQUFFLElBQUlJO1lBQ2pCdEQsSUFBSSxDQUFDa0QsTUFBTSxFQUFFLElBQUlJO1FBQ25CO0lBQ0Y7SUFFQTVELElBQUllLFlBQVksQ0FBQ2IsV0FBVyxHQUFHO0FBQ2pDO0FBRUEsaUJBQWlCO0FBQ2pCLE1BQU1RLFdBQVcsQ0FBQ1YsS0FBK0JJLE9BQWVDLFFBQWdCNEM7SUFDOUUsTUFBTS9DLFlBQVlGLElBQUlHLFlBQVksQ0FBQyxHQUFHLEdBQUdDLE9BQU9DO0lBQ2hELE1BQU1DLE9BQU9KLFVBQVVJLElBQUk7SUFDM0IsTUFBTXVELGdCQUFnQlosU0FBUztJQUUvQixJQUFLLElBQUlqQyxJQUFJLEdBQUdBLElBQUlWLEtBQUtXLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3ZDLE1BQU04QyxRQUFRLENBQUN0QyxLQUFLdUMsTUFBTSxLQUFLLEdBQUUsSUFBS0YsZ0JBQWdCO1FBQ3REdkQsSUFBSSxDQUFDVSxFQUFFLEdBQUdRLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsS0FBS3BCLElBQUksQ0FBQ1UsRUFBRSxHQUFHOEM7UUFDOUN4RCxJQUFJLENBQUNVLElBQUksRUFBRSxHQUFHUSxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDLEtBQUtwQixJQUFJLENBQUNVLElBQUksRUFBRSxHQUFHOEM7UUFDdER4RCxJQUFJLENBQUNVLElBQUksRUFBRSxHQUFHUSxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDLEtBQUtwQixJQUFJLENBQUNVLElBQUksRUFBRSxHQUFHOEM7SUFDeEQ7SUFFQTlELElBQUllLFlBQVksQ0FBQ2IsV0FBVyxHQUFHO0FBQ2pDO0FBRUEscURBQXFEO0FBQzlDLE1BQU04RCxlQUFlLENBQUNsRTtBQUMzQix3RUFBd0U7QUFDMUUsRUFBRTtBQUVLLE1BQU1tRSxlQUFlLENBQUNuRTtBQUMzQiw4RUFBOEU7QUFDaEYsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3JvbWFuL0RldmVsb3BtZW50L2tlZXBzYWtlL3JldHJvL3JldHJvLWFwcGxlLXBob3RvYm9vdGgvbGliL2ZpbHRlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGhvdG9GaWx0ZXIgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG5leHBvcnQgY29uc3QgYXBwbHlGaWx0ZXIgPSAoXG4gIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXG4gIGZpbHRlcjogUGhvdG9GaWx0ZXJcbik6IHZvaWQgPT4ge1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBpZiAoIWN0eCkgcmV0dXJuO1xuXG4gIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXG4gIHN3aXRjaCAoZmlsdGVyKSB7XG4gICAgY2FzZSBcIjM1bW0tZmlsbVwiOlxuICAgICAgYXBwbHkzNW1tRmlsbUZpbHRlcihkYXRhLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInZpbnRhZ2Utc2VwaWFcIjpcbiAgICAgIGFwcGx5VmludGFnZVNlcGlhRmlsdGVyKGRhdGEsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBhZGRWaWduZXR0ZShjdHgsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgMC4yNSk7XG4gICAgICBhZGRHcmFpbihjdHgsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgMzgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJ3LW1pbmltYWxcIjpcbiAgICAgIGFwcGx5QldNaW5pbWFsRmlsdGVyKGRhdGEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJ3LXYzXCI6XG4gICAgICBhcHBseUJXVjNGaWx0ZXIoZGF0YSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwia29kYWstZmlsbVwiOlxuICAgICAgYXBwbHlLb2Rha0ZpbG1GaWx0ZXIoZGF0YSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwia29kYWstcG9ydHJhXCI6XG4gICAgICBhcHBseUtvZGFrUG9ydHJhRmlsdGVyKGRhdGEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vbmVcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xufTtcblxuLy8gMzVtbSBGaWxtIEZpbHRlclxuLy8gQmFzZWQgb246IEV4cG9zdXJlIC0wLjQ3LCBDb250cmFzdCArNDAsIEhpZ2hsaWdodHMgKzIzLCBTaGFkb3dzIC0xNVxuLy8gQ2xhcml0eSAtMTksIFZpYnJhbmNlICsxMywgd2FybSB0b25lXG5jb25zdCBhcHBseTM1bW1GaWxtRmlsdGVyID0gKGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBsZXQgciA9IGRhdGFbaV07XG4gICAgbGV0IGcgPSBkYXRhW2kgKyAxXTtcbiAgICBsZXQgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgLy8gUmVkdWNlIGV4cG9zdXJlIHNsaWdodGx5XG4gICAgciAqPSAwLjg1O1xuICAgIGcgKj0gMC44NTtcbiAgICBiICo9IDAuODU7XG5cbiAgICAvLyBXYXJtIHRvbmUgKGFkZCB3YXJtdGgsIHJlZHVjZSBibHVlL2N5YW4pXG4gICAgciAqPSAxLjEyO1xuICAgIGcgKj0gMS4wMztcbiAgICBiICo9IDAuOTI7XG5cbiAgICAvLyBJbmNyZWFzZSBjb250cmFzdFxuICAgIHIgPSAoKHIgLyAyNTUgLSAwLjUpICogMS40ICsgMC41KSAqIDI1NTtcbiAgICBnID0gKChnIC8gMjU1IC0gMC41KSAqIDEuNCArIDAuNSkgKiAyNTU7XG4gICAgYiA9ICgoYiAvIDI1NSAtIDAuNSkgKiAxLjQgKyAwLjUpICogMjU1O1xuXG4gICAgLy8gQm9vc3QgdmlicmFuY2UgKGVuaGFuY2UgbWlkLXRvbmVzKVxuICAgIGNvbnN0IGF2ZyA9IChyICsgZyArIGIpIC8gMztcbiAgICBjb25zdCBzYXR1cmF0aW9uQm9vc3QgPSAxLjEzO1xuICAgIHIgPSBhdmcgKyAociAtIGF2ZykgKiBzYXR1cmF0aW9uQm9vc3Q7XG4gICAgZyA9IGF2ZyArIChnIC0gYXZnKSAqIHNhdHVyYXRpb25Cb29zdDtcbiAgICBiID0gYXZnICsgKGIgLSBhdmcpICogc2F0dXJhdGlvbkJvb3N0O1xuXG4gICAgLy8gQXBwbHkgdG9uZSBjdXJ2ZSAobGlmdCBzaGFkb3dzLCBjb21wcmVzcyBoaWdobGlnaHRzKVxuICAgIHIgPSBhcHBseVRvbmVDdXJ2ZShyLCBbXG4gICAgICBbMCwgMF0sIFs1OSwgNjJdLCBbMTMwLCAxMjddLCBbMTk1LCAxOTddLCBbMjI3LCAyMjhdLCBbMjU1LCAyNTVdXG4gICAgXSk7XG4gICAgZyA9IGFwcGx5VG9uZUN1cnZlKGcsIFtcbiAgICAgIFswLCAwXSwgWzU5LCA2Ml0sIFsxMzAsIDEyN10sIFsxOTUsIDE5N10sIFsyMjcsIDIyOF0sIFsyNTUsIDI1NV1cbiAgICBdKTtcbiAgICBiID0gYXBwbHlUb25lQ3VydmUoYiwgW1xuICAgICAgWzAsIDBdLCBbNTksIDYyXSwgWzEzMCwgMTI3XSwgWzE5NSwgMTk3XSwgWzIyNywgMjI4XSwgWzI1NSwgMjU1XVxuICAgIF0pO1xuXG4gICAgZGF0YVtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcikpO1xuICAgIGRhdGFbaSArIDFdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBnKSk7XG4gICAgZGF0YVtpICsgMl0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIGIpKTtcbiAgfVxufTtcblxuLy8gVmludGFnZSBQaG90b2Jvb3RoIEZpbHRlclxuLy8gSGlnaCBjb250cmFzdCBCJlcgd2l0aCBzdWJ0bGUgd2FybSB0aW50LCBibG93bi1vdXQgaGlnaGxpZ2h0cywgZGVlcCBzaGFkb3dzXG4vLyBBdXRoZW50aWMgMTk3MHMgZGVwYXJ0bWVudCBzdG9yZSBwaG90b2Jvb3RoIGFlc3RoZXRpY1xuLy8gTk9UIHRyYWRpdGlvbmFsIHNlcGlhIC0gdGhpcyBpcyA5NSUgZ3JheXNjYWxlIHdpdGggbWluaW1hbCB3YXJtdGhcbmNvbnN0IGFwcGx5VmludGFnZVNlcGlhRmlsdGVyID0gKGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBsZXQgciA9IGRhdGFbaV07XG4gICAgbGV0IGcgPSBkYXRhW2kgKyAxXTtcbiAgICBsZXQgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgLy8gMS4gQ29udmVydCB0byBncmF5c2NhbGUgd2l0aCBjdXN0b20gd2VpZ2h0cyAoZW1waGFzaXplIHJlZCBjaGFubmVsIGZvciBsdW1pbm91cyBza2luKVxuICAgIGNvbnN0IGdyYXkgPSByICogMC40ICsgZyAqIDAuNCArIGIgKiAwLjI7XG5cbiAgICAvLyAyLiBBcHBseSBTLWN1cnZlIGZvciBoaWdoIGNvbnRyYXN0IHdpdGggYmxvd24gaGlnaGxpZ2h0cyBhbmQgZGVlcCBzaGFkb3dzXG4gICAgbGV0IGFkanVzdGVkID0gZ3JheSAvIDI1NTtcblxuICAgIC8vIEJyaWdodGVuIG1pZHRvbmVzXG4gICAgYWRqdXN0ZWQgPSBNYXRoLnBvdyhhZGp1c3RlZCwgMC43KTtcblxuICAgIC8vIEFwcGx5IGNvbnRyYXN0IGN1cnZlXG4gICAgaWYgKGFkanVzdGVkID4gMC41KSB7XG4gICAgICAvLyBCb29zdCBoaWdobGlnaHRzIChjcmVhdGUgYmxvd24tb3V0IGJyaWdodCBhcmVhcyBvbiBza2luKVxuICAgICAgYWRqdXN0ZWQgPSAwLjUgKyBNYXRoLnBvdygoYWRqdXN0ZWQgLSAwLjUpICogMiwgMC44KSAqIDAuNTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcGVuIHNoYWRvd3Mgd2hpbGUgcmV0YWluaW5nIGRldGFpbFxuICAgICAgYWRqdXN0ZWQgPSBNYXRoLnBvdyhhZGp1c3RlZCAqIDIsIDEuMykgKiAwLjU7XG4gICAgfVxuXG4gICAgYWRqdXN0ZWQgPSBhZGp1c3RlZCAqIDI1NTtcblxuICAgIC8vIDMuIEFkZCBWRVJZIHN1YnRsZSB3YXJtIHRpbnQgKGJhcmVseSBub3RpY2VhYmxlIC0gbm90IGJyb3duIHNlcGlhKVxuICAgIHIgPSBNYXRoLm1pbigyNTUsIGFkanVzdGVkICogMS4wMik7ICAvLyBUaW55IHJlZCBib29zdFxuICAgIGcgPSBNYXRoLm1pbigyNTUsIGFkanVzdGVkICogMC45OSk7ICAvLyBTbGlnaHQgZ3JlZW4gcmVkdWN0aW9uXG4gICAgYiA9IE1hdGgubWluKDI1NSwgYWRqdXN0ZWQgKiAwLjk3KTsgIC8vIFNsaWdodCBibHVlIHJlZHVjdGlvblxuXG4gICAgZGF0YVtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcikpO1xuICAgIGRhdGFbaSArIDFdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBnKSk7XG4gICAgZGF0YVtpICsgMl0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIGIpKTtcbiAgfVxufTtcblxuLy8gQiZXIE1pbmltYWwgRmlsdGVyXG4vLyBCYXNlZCBvbjogSGlnaCBjb250cmFzdCBCJlcsIEV4cG9zdXJlIC0wLjE1LCBDb250cmFzdCArNDdcbi8vIEhpZ2hsaWdodHMgLTY0LCBDbGFyaXR5ICsxNlxuY29uc3QgYXBwbHlCV01pbmltYWxGaWx0ZXIgPSAoZGF0YTogVWludDhDbGFtcGVkQXJyYXkpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgY29uc3QgciA9IGRhdGFbaV07XG4gICAgY29uc3QgZyA9IGRhdGFbaSArIDFdO1xuICAgIGNvbnN0IGIgPSBkYXRhW2kgKyAyXTtcblxuICAgIC8vIENvbnZlcnQgdG8gZ3JheXNjYWxlIHdpdGggY3VzdG9tIHdlaWdodGluZ1xuICAgIGxldCBncmF5ID0gMC4yOTkgKiByICsgMC41ODcgKiBnICsgMC4xMTQgKiBiO1xuXG4gICAgLy8gUmVkdWNlIGV4cG9zdXJlXG4gICAgZ3JheSAqPSAwLjg1O1xuXG4gICAgLy8gSW5jcmVhc2UgY29udHJhc3Qgc2lnbmlmaWNhbnRseVxuICAgIGdyYXkgPSAoKGdyYXkgLyAyNTUgLSAwLjUpICogMS40NyArIDAuNSkgKiAyNTU7XG5cbiAgICAvLyBDcnVzaCBoaWdobGlnaHRzIChjb21wcmVzcyBicmlnaHQgYXJlYXMpXG4gICAgaWYgKGdyYXkgPiAxODApIHtcbiAgICAgIGdyYXkgPSAxODAgKyAoZ3JheSAtIDE4MCkgKiAwLjU7XG4gICAgfVxuXG4gICAgLy8gQWRkIGNsYXJpdHkgKG1pY3JvLWNvbnRyYXN0KVxuICAgIGNvbnN0IGNsYXJpdHkgPSAxLjE2O1xuICAgIGdyYXkgPSAoKGdyYXkgLyAyNTUgLSAwLjUpICogY2xhcml0eSArIDAuNSkgKiAyNTU7XG5cbiAgICBjb25zdCBmaW5hbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgZ3JheSkpO1xuICAgIGRhdGFbaV0gPSBmaW5hbDtcbiAgICBkYXRhW2kgKyAxXSA9IGZpbmFsO1xuICAgIGRhdGFbaSArIDJdID0gZmluYWw7XG4gIH1cbn07XG5cbi8vIEImVyBWMyBGaWx0ZXJcbi8vIEJhc2VkIG9uOiBFeHRyZW1lIGNvbnRyYXN0IEImVywgRXhwb3N1cmUgLTAuMjcsIENvbnRyYXN0ICs2OVxuLy8gSGlnaGxpZ2h0cyAtODEsIFNoYWRvd3MgKzUzLCBDbGFyaXR5ICszNFxuY29uc3QgYXBwbHlCV1YzRmlsdGVyID0gKGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5KSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGNvbnN0IHIgPSBkYXRhW2ldO1xuICAgIGNvbnN0IGcgPSBkYXRhW2kgKyAxXTtcbiAgICBjb25zdCBiID0gZGF0YVtpICsgMl07XG5cbiAgICAvLyBDb252ZXJ0IHRvIGdyYXlzY2FsZVxuICAgIGxldCBncmF5ID0gMC4yOTkgKiByICsgMC41ODcgKiBnICsgMC4xMTQgKiBiO1xuXG4gICAgLy8gUmVkdWNlIGV4cG9zdXJlXG4gICAgZ3JheSAqPSAwLjczO1xuXG4gICAgLy8gRXh0cmVtZSBjb250cmFzdFxuICAgIGdyYXkgPSAoKGdyYXkgLyAyNTUgLSAwLjUpICogMS42OSArIDAuNSkgKiAyNTU7XG5cbiAgICAvLyBMaWZ0IHNoYWRvd3Mgc2lnbmlmaWNhbnRseVxuICAgIGlmIChncmF5IDwgMTAwKSB7XG4gICAgICBncmF5ID0gZ3JheSArICgxMDAgLSBncmF5KSAqIDAuNTM7XG4gICAgfVxuXG4gICAgLy8gQ3J1c2ggaGlnaGxpZ2h0cyBkcmFtYXRpY2FsbHlcbiAgICBpZiAoZ3JheSA+IDE3MCkge1xuICAgICAgZ3JheSA9IDE3MCArIChncmF5IC0gMTcwKSAqIDAuMztcbiAgICB9XG5cbiAgICAvLyBBZGQgc3Ryb25nIGNsYXJpdHlcbiAgICBjb25zdCBjbGFyaXR5ID0gMS4zNDtcbiAgICBncmF5ID0gKChncmF5IC8gMjU1IC0gMC41KSAqIGNsYXJpdHkgKyAwLjUpICogMjU1O1xuXG4gICAgY29uc3QgZmluYWwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIGdyYXkpKTtcbiAgICBkYXRhW2ldID0gZmluYWw7XG4gICAgZGF0YVtpICsgMV0gPSBmaW5hbDtcbiAgICBkYXRhW2kgKyAyXSA9IGZpbmFsO1xuICB9XG59O1xuXG4vLyBLb2RhayBGaWxtIEZpbHRlclxuLy8gQmFzZWQgb246IFdhcm0gbm9zdGFsZ2ljIGZpbG0gbG9vaywgRXhwb3N1cmUgKzAuMjUsIENvbnRyYXN0ICsxNVxuLy8gVmlicmFuY2UgKzIyLCBTYXR1cmF0aW9uICsxMCwgd2FybSBjb2xvciBncmFkaW5nXG5jb25zdCBhcHBseUtvZGFrRmlsbUZpbHRlciA9IChkYXRhOiBVaW50OENsYW1wZWRBcnJheSkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBsZXQgciA9IGRhdGFbaV07XG4gICAgbGV0IGcgPSBkYXRhW2kgKyAxXTtcbiAgICBsZXQgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgLy8gSW5jcmVhc2UgZXhwb3N1cmVcbiAgICByICo9IDEuMjU7XG4gICAgZyAqPSAxLjI1O1xuICAgIGIgKj0gMS4yNTtcblxuICAgIC8vIEFkZCB3YXJtIEtvZGFrIGNvbG9yIGNhc3RcbiAgICByICo9IDEuMTU7XG4gICAgZyAqPSAxLjA1O1xuICAgIGIgKj0gMC45MztcblxuICAgIC8vIEluY3JlYXNlIGNvbnRyYXN0IG1vZGVyYXRlbHlcbiAgICByID0gKChyIC8gMjU1IC0gMC41KSAqIDEuMTUgKyAwLjUpICogMjU1O1xuICAgIGcgPSAoKGcgLyAyNTUgLSAwLjUpICogMS4xNSArIDAuNSkgKiAyNTU7XG4gICAgYiA9ICgoYiAvIDI1NSAtIDAuNSkgKiAxLjE1ICsgMC41KSAqIDI1NTtcblxuICAgIC8vIEJvb3N0IHZpYnJhbmNlIGFuZCBzYXR1cmF0aW9uXG4gICAgY29uc3QgYXZnID0gKHIgKyBnICsgYikgLyAzO1xuICAgIGNvbnN0IHZpYnJhbmNlQm9vc3QgPSAxLjIyO1xuICAgIHIgPSBhdmcgKyAociAtIGF2ZykgKiB2aWJyYW5jZUJvb3N0ICogMS4xMDtcbiAgICBnID0gYXZnICsgKGcgLSBhdmcpICogdmlicmFuY2VCb29zdCAqIDEuMTA7XG4gICAgYiA9IGF2ZyArIChiIC0gYXZnKSAqIHZpYnJhbmNlQm9vc3QgKiAxLjEwO1xuXG4gICAgLy8gS29kYWsgc2lnbmF0dXJlIHdhcm0gbWlkdG9uZSBzaGlmdFxuICAgIGNvbnN0IGx1bWluYW5jZSA9IChyICsgZyArIGIpIC8gMyAvIDI1NTtcbiAgICBpZiAobHVtaW5hbmNlID4gMC4zICYmIGx1bWluYW5jZSA8IDAuNykge1xuICAgICAgciAqPSAxLjA4O1xuICAgICAgZyAqPSAxLjAzO1xuICAgIH1cblxuICAgIGRhdGFbaV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHIpKTtcbiAgICBkYXRhW2kgKyAxXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgZykpO1xuICAgIGRhdGFbaSArIDJdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBiKSk7XG4gIH1cbn07XG5cbi8vIEtvZGFrIFBvcnRyYSA0MDAgRmlsdGVyXG4vLyBCYXNlZCBvbjogU29mdCwgY3JlYW15IHNraW4gdG9uZXMsIEV4cG9zdXJlICswLjEyLCBDb250cmFzdCAtNVxuLy8gSGlnaGxpZ2h0cyAtMjIsIFNoYWRvd3MgKzE4LCBWaWJyYW5jZSArMjUsIHNvZnQgcGFzdGVsIGxvb2tcbmNvbnN0IGFwcGx5S29kYWtQb3J0cmFGaWx0ZXIgPSAoZGF0YTogVWludDhDbGFtcGVkQXJyYXkpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgbGV0IHIgPSBkYXRhW2ldO1xuICAgIGxldCBnID0gZGF0YVtpICsgMV07XG4gICAgbGV0IGIgPSBkYXRhW2kgKyAyXTtcblxuICAgIC8vIFNsaWdodCBleHBvc3VyZSBib29zdFxuICAgIHIgKj0gMS4xMjtcbiAgICBnICo9IDEuMTI7XG4gICAgYiAqPSAxLjEyO1xuXG4gICAgLy8gUmVkdWNlIGNvbnRyYXN0IGZvciBzb2Z0IGxvb2tcbiAgICByID0gKChyIC8gMjU1IC0gMC41KSAqIDAuOTUgKyAwLjUpICogMjU1O1xuICAgIGcgPSAoKGcgLyAyNTUgLSAwLjUpICogMC45NSArIDAuNSkgKiAyNTU7XG4gICAgYiA9ICgoYiAvIDI1NSAtIDAuNSkgKiAwLjk1ICsgMC41KSAqIDI1NTtcblxuICAgIC8vIFBvcnRyYSdzIHNpZ25hdHVyZSBjcmVhbXkgd2FybXRoXG4gICAgciAqPSAxLjA4O1xuICAgIGcgKj0gMS4wNDtcbiAgICBiICo9IDAuOTc7XG5cbiAgICAvLyBMaWZ0IHNoYWRvd3MgKG9wZW4gdXAgZGFyayBhcmVhcylcbiAgICBjb25zdCBsdW1pbmFuY2UgPSAociArIGcgKyBiKSAvIDM7XG4gICAgaWYgKGx1bWluYW5jZSA8IDEwMCkge1xuICAgICAgY29uc3QgbGlmdCA9IDEuMTg7XG4gICAgICByICo9IGxpZnQ7XG4gICAgICBnICo9IGxpZnQ7XG4gICAgICBiICo9IGxpZnQ7XG4gICAgfVxuXG4gICAgLy8gUHVsbCBkb3duIGhpZ2hsaWdodHMgKHNvZnQsIG5vdCBibG93biBvdXQpXG4gICAgaWYgKGx1bWluYW5jZSA+IDE4MCkge1xuICAgICAgY29uc3QgY29tcHJlc3MgPSAwLjg1O1xuICAgICAgciAqPSBjb21wcmVzcztcbiAgICAgIGcgKj0gY29tcHJlc3M7XG4gICAgICBiICo9IGNvbXByZXNzO1xuICAgIH1cblxuICAgIC8vIEJvb3N0IHZpYnJhbmNlIGZvciBwYXN0ZWwgcXVhbGl0eVxuICAgIGNvbnN0IGF2ZyA9IChyICsgZyArIGIpIC8gMztcbiAgICBjb25zdCB2aWJyYW5jZUJvb3N0ID0gMS4yNTtcbiAgICByID0gYXZnICsgKHIgLSBhdmcpICogdmlicmFuY2VCb29zdDtcbiAgICBnID0gYXZnICsgKGcgLSBhdmcpICogdmlicmFuY2VCb29zdDtcbiAgICBiID0gYXZnICsgKGIgLSBhdmcpICogdmlicmFuY2VCb29zdDtcblxuICAgIC8vIFBvcnRyYSBncmVlbi1tYWdlbnRhIHNoaWZ0XG4gICAgZyAqPSAxLjAyO1xuXG4gICAgZGF0YVtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcikpO1xuICAgIGRhdGFbaSArIDFdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBnKSk7XG4gICAgZGF0YVtpICsgMl0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIGIpKTtcbiAgfVxufTtcblxuLy8gSGVscGVyOiBBcHBseSB0b25lIGN1cnZlXG5jb25zdCBhcHBseVRvbmVDdXJ2ZSA9ICh2YWx1ZTogbnVtYmVyLCBjdXJ2ZTogbnVtYmVyW11bXSk6IG51bWJlciA9PiB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB2YWx1ZSAvIDI1NTtcblxuICAvLyBGaW5kIHRoZSB0d28gcG9pbnRzIHRvIGludGVycG9sYXRlIGJldHdlZW5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJ2ZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBbeDEsIHkxXSA9IGN1cnZlW2ldO1xuICAgIGNvbnN0IFt4MiwgeTJdID0gY3VydmVbaSArIDFdO1xuXG4gICAgY29uc3QgbngxID0geDEgLyAyNTU7XG4gICAgY29uc3QgbngyID0geDIgLyAyNTU7XG5cbiAgICBpZiAobm9ybWFsaXplZCA+PSBueDEgJiYgbm9ybWFsaXplZCA8PSBueDIpIHtcbiAgICAgIC8vIExpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICBjb25zdCB0ID0gKG5vcm1hbGl6ZWQgLSBueDEpIC8gKG54MiAtIG54MSk7XG4gICAgICBjb25zdCBueTEgPSB5MSAvIDI1NTtcbiAgICAgIGNvbnN0IG55MiA9IHkyIC8gMjU1O1xuICAgICAgY29uc3QgcmVzdWx0ID0gbnkxICsgdCAqIChueTIgLSBueTEpO1xuICAgICAgcmV0dXJuIHJlc3VsdCAqIDI1NTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBBZGQgdmlnbmV0dGUgZWZmZWN0XG5jb25zdCBhZGRWaWduZXR0ZSA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGFtb3VudDogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgY29uc3QgY2VudGVyWCA9IHdpZHRoIC8gMjtcbiAgY29uc3QgY2VudGVyWSA9IGhlaWdodCAvIDI7XG4gIGNvbnN0IG1heERpc3QgPSBNYXRoLnNxcnQoY2VudGVyWCAqIGNlbnRlclggKyBjZW50ZXJZICogY2VudGVyWSk7XG5cbiAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgY29uc3QgaWR4ID0gKHkgKiB3aWR0aCArIHgpICogNDtcbiAgICAgIGNvbnN0IGR4ID0geCAtIGNlbnRlclg7XG4gICAgICBjb25zdCBkeSA9IHkgLSBjZW50ZXJZO1xuICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBjb25zdCB2aWduZXR0ZSA9IDEgLSAoZGlzdCAvIG1heERpc3QpICogYW1vdW50O1xuXG4gICAgICBkYXRhW2lkeF0gKj0gdmlnbmV0dGU7XG4gICAgICBkYXRhW2lkeCArIDFdICo9IHZpZ25ldHRlO1xuICAgICAgZGF0YVtpZHggKyAyXSAqPSB2aWduZXR0ZTtcbiAgICB9XG4gIH1cblxuICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG59O1xuXG4vLyBBZGQgZmlsbSBncmFpblxuY29uc3QgYWRkR3JhaW4gPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBhbW91bnQ6IG51bWJlcikgPT4ge1xuICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gIGNvbnN0IGdyYWluU3RyZW5ndGggPSBhbW91bnQgLyAxMDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgY29uc3QgZ3JhaW4gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBncmFpblN0cmVuZ3RoICogNTA7XG4gICAgZGF0YVtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgZGF0YVtpXSArIGdyYWluKSk7XG4gICAgZGF0YVtpICsgMV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIGRhdGFbaSArIDFdICsgZ3JhaW4pKTtcbiAgICBkYXRhW2kgKyAyXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgZGF0YVtpICsgMl0gKyBncmFpbikpO1xuICB9XG5cbiAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xufTtcblxuLy8gQ1JUIGFuZCBTY2FubGluZXMgZWZmZWN0cyAoa2VwdCBmb3IgY29tcGF0aWJpbGl0eSlcbmV4cG9ydCBjb25zdCBhZGRDUlRFZmZlY3QgPSAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQgPT4ge1xuICAvLyBDUlQgbm90IHVzZWQgaW4gS2VlcHNha2UgcHJlc2V0cyBidXQga2VlcGluZyBmb3IgcG90ZW50aWFsIGZ1dHVyZSB1c2Vcbn07XG5cbmV4cG9ydCBjb25zdCBhZGRTY2FubGluZXMgPSAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQgPT4ge1xuICAvLyBTY2FubGluZXMgbm90IHVzZWQgaW4gS2VlcHNha2UgcHJlc2V0cyBidXQga2VlcGluZyBmb3IgcG90ZW50aWFsIGZ1dHVyZSB1c2Vcbn07XG4iXSwibmFtZXMiOlsiYXBwbHlGaWx0ZXIiLCJjYW52YXMiLCJmaWx0ZXIiLCJjdHgiLCJnZXRDb250ZXh0IiwiaW1hZ2VEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwid2lkdGgiLCJoZWlnaHQiLCJkYXRhIiwiYXBwbHkzNW1tRmlsbUZpbHRlciIsImFwcGx5VmludGFnZVNlcGlhRmlsdGVyIiwiYWRkVmlnbmV0dGUiLCJhZGRHcmFpbiIsImFwcGx5QldNaW5pbWFsRmlsdGVyIiwiYXBwbHlCV1YzRmlsdGVyIiwiYXBwbHlLb2Rha0ZpbG1GaWx0ZXIiLCJhcHBseUtvZGFrUG9ydHJhRmlsdGVyIiwicHV0SW1hZ2VEYXRhIiwiaSIsImxlbmd0aCIsInIiLCJnIiwiYiIsImF2ZyIsInNhdHVyYXRpb25Cb29zdCIsImFwcGx5VG9uZUN1cnZlIiwiTWF0aCIsIm1heCIsIm1pbiIsImdyYXkiLCJhZGp1c3RlZCIsInBvdyIsImNsYXJpdHkiLCJmaW5hbCIsInZpYnJhbmNlQm9vc3QiLCJsdW1pbmFuY2UiLCJsaWZ0IiwiY29tcHJlc3MiLCJ2YWx1ZSIsImN1cnZlIiwibm9ybWFsaXplZCIsIngxIiwieTEiLCJ4MiIsInkyIiwibngxIiwibngyIiwidCIsIm55MSIsIm55MiIsInJlc3VsdCIsImFtb3VudCIsImNlbnRlclgiLCJjZW50ZXJZIiwibWF4RGlzdCIsInNxcnQiLCJ5IiwieCIsImlkeCIsImR4IiwiZHkiLCJkaXN0IiwidmlnbmV0dGUiLCJncmFpblN0cmVuZ3RoIiwiZ3JhaW4iLCJyYW5kb20iLCJhZGRDUlRFZmZlY3QiLCJhZGRTY2FubGluZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/filters.ts\n"));

/***/ })

});